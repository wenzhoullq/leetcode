## 模板
层次遍历，建立一个队列，每一层次就是当前队列的长度,太简单了不想写模板
* 32.-I 从上到下打印二叉树I
##### 题目
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
##### 思路
最简单的
```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        ArrayList<Integer> ans=new ArrayList<Integer>();
        if(root==null) return new int[0];
        q.offer(root);
        while(!q.isEmpty()){
            int length=q.size();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null)q.offer(temp.left);
                if(temp.right!=null)q.offer(temp.right);
                ans.add(temp.val);
            }
        }
        int[] Ans=new int[ans.size()];
        for(int i=0;i<ans.size();i++) Ans[i]=ans.get(i);//因为只有java8里才有将ArrayList<Integer>转换为 int[],因此自己新建一个数组
        return Ans;
    }
}
```
* 32.-II 从上到下打印二叉树II
##### 题目
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
##### 思路
仅改变输入方式
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new LinkedList<List<Integer>>();
        if(root==null) return ans;
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        q.offer(root);
        while(!q.isEmpty()){
            LinkedList<Integer> temp=new LinkedList<>();
            int length=q.size();
            for(int i=0;i<length;i++) {
                TreeNode Temp=q.poll();
                if(Temp.left!=null)q.offer(Temp.left);
                if(Temp.right!=null) q.offer(Temp.right);
                temp.add(Temp.val);
            }
            ans.add(temp);
        }
        return ans;
    }
}
```
* 32.-III 从上到下打印二叉树III
##### 题目
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
##### 思路
Collections.reverse()可以反转链表
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans=new ArrayList<>();
        if(root==null) return ans;
        int count=0;
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        q.offer(root);
        while(!q.isEmpty()){
            LinkedList<Integer> temp=new LinkedList<>();
            int length=q.size();
            for(int i=0;i<length;i++){
                TreeNode Temp=q.poll();
                if(Temp.left!=null) q.offer(Temp.left);
                if(Temp.right!=null) q.offer(Temp.right);
                temp.add(Temp.val);
            }
            if(count++%2!=0) Collections.reverse(temp);//反转链表
            ans.add(temp);
        }
        return ans;
    }
}
```
