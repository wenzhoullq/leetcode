## 题目

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

## 思路

经典滑动窗口最大值题，做了好多遍了，不细写了

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length==0||k==0) return new int[0];
        Deque<Integer> q=new ArrayDeque<Integer>();
        int[] ans=new int[nums.length-k+1];
        int count=0;
        for(int i=0;i<k;i++){
             while(!q.isEmpty()){
                if(nums[i]>=nums[q.getLast()]) q.removeLast();
                else break;
            }
                q.offer(i);
        }
        ans[count++]=nums[q.getFirst()];
        for(int i=k;i<nums.length;i++){
            if(q.getFirst()<=i-k) q.removeFirst();
            while(!q.isEmpty()){
                if(nums[i]>=nums[q.getLast()]) q.removeLast();
                else break;
            }
            q.offer(i);
            ans[count++]=nums[q.getFirst()]; 
        }
        return ans;
    }
}
```

* 59.II. 队列的最大值

  ## 题目

  请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1

  ## 思路

  类似于前面的滑动窗口最大值的思路

  ```java
  class MaxQueue {
      Deque<Integer> nor;
      Deque<Integer> max;
      public MaxQueue() {
         nor=new ArrayDeque<Integer>();
         max=new ArrayDeque<Integer>();
      }
      
      public int max_value() {
           if(nor.isEmpty()) return -1;
           return max.peekFirst();
      }
      
      public void push_back(int value) {
          nor.offer(value);
          while(!max.isEmpty()&&value>max.getLast()) max.removeLast();
          while(max.size()<nor.size()) max.offer(value);
      }
      
      public int pop_front() {
          if(nor.isEmpty()) return -1;
          max.removeFirst();
          int ans=nor.getFirst();
          nor.removeFirst();
          return ans;
      }
  }
  
  ```

  
