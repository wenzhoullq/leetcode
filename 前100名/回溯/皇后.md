## 模板
```java
  boolean[] row=new boolean[10],col=new boolean[10],leftdown=new boolean[50],rightdown=new boolean[50];
    void backtrack(int y){//没有x
        if(y==n){
            return ;
        }//y==n即可返回
        for(int x=0;x<n;x++){
            if(row[y]||col[x]||rightdown[y-x+n]||leftdown[y+x]) continue;
                row[y]=true;
                col[x]=true;
                rightdown[y-x+n]=true;
                leftdown[y+x]=true;
                backtrack(y+1);
                row[y]=false;
                col[x]=false;
                rightdown[y-x+n]=false;
                leftdown[y+x]=false;
         }
```
* 52.N皇后 II
## 题目
n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。
## 思路
模板题
```java
class Solution {
    int ans=0;
    int n;
    boolean[] row=new boolean[10],col=new boolean[10],leftdown=new boolean[50],rightdown=new boolean[50];
    void backtrack(int y){
        if(y==n){
            ans++;
            return ;
        }
        for(int x=0;x<n;x++){
            if(row[y]||col[x]||rightdown[y-x+n]||leftdown[y+x]) continue;
                row[y]=true;
                col[x]=true;
                rightdown[y-x+n]=true;
                leftdown[y+x]=true;
                backtrack(y+1);
                row[y]=false;
                col[x]=false;
                rightdown[y-x+n]=false;
                leftdown[y+x]=false;
         }
    }
    public int totalNQueens(int n) {
        this.n=n;
        backtrack(0);
        return ans;
    }
}
```
