## 分析
岛屿题一般使用回溯，具体模板在别的例题里中有

*  200.岛屿数量
## 题目
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

## 思路
回溯
```java
class Solution {
    int[][] visit;
    int[][] direct={{1,0},{-1,0},{0,1},{0,-1}};
    int huisu(int y,int x,int lengthx, int lengthy,char[][] grid){
        if(x>=lengthx||x<0||y<0||y>=lengthy||visit[y][x]==1||grid[y][x]!='1') return 0;
        visit[y][x]=1;
        for(int i=0;i<4;i++){
            huisu(y+direct[i][0],x+direct[i][1],lengthx,lengthy,grid);
        }
        return 1;
    }
    public int numIslands(char[][] grid) {
        if(grid.length==0||grid[0].length==0) return 0;
        int ans=0;
        visit=new int[grid.length][grid[0].length];
        for(int y=0;y<grid.length;y++){
            for(int x=0;x<grid[0].length;x++){
                ans+=huisu(y,x,grid[0].length,grid.length,grid);
            }
        }
        return ans;
    }
}
```
*  463.岛屿的周长
## 题目
给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

## 思路
碰到不行的+1
```java
class Solution {
    boolean[][] visit;
    int[][] grid,dircect={{0,1},{0,-1},{1,0},{-1,0}};
    int lengthy,lengthx;
    int ans=0;
    int dfs(int y,int x){
        if(y<0||y==lengthy||x<0||x==lengthx) return 1;
        if(visit[y][x]) return 0;
        if(grid[y][x]==0) return 1;
        visit[y][x]=true;
        int temp=0;
        for(int i=0;i<4;i++){
            //  System.out.println(temp);
            temp+=dfs(y+dircect[i][0],x+dircect[i][1]);
        }
        return temp;
    }
    public int islandPerimeter(int[][] grid) {
        this.grid=grid;
        this.lengthy=grid.length;
        this.lengthx=grid[0].length;
        visit=new boolean[lengthy][lengthx];
        for(int i=0;i<lengthy;i++){
            for(int j=0;j<lengthx;j++){
                if(grid[i][j]==1)ans+=dfs(i,j);
                // System.out.println(ans);
            }
        }
        return ans;
    }
}
```
