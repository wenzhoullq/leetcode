## 模板
全排列回溯分两种，一种是去重全排列，另一种是无去重全排列
* 无去重全排列
字符串全排列的题目主要体现在for(int i=0) 是从头开始的，同时为了避免重复，增加一个visit数组
```java
  void backtrack(){
      if(满足条件){
        增加;
        return;
      }
      for(int i=0;i<nums.length;i++){
        if(visit[i]) continue;
        visit[i]=true;
        temp增加;
        backtrack(i+1);
        temp移除;
        visit[i]=false;
      }
     }
      main(){
        backtrack();
        return ans;
      }
  }
```
* 去重全排列
去重全排列需要对**数组进行排序**，然后**各种枝剪**，最重要的去重是while(i+1<nums.length&&nums[i]==nums[i+1]),不然大概率超时
```java
  boolean backtrack(int index,int k){
      if(满足条件){
        if(k==1) return true;
        if(backtrack(0,k-1)) return true;//这里的0非常细节
      }
      for(int i=index;i<nums.length;i++){ //因为是排序好的数组，因此可以用i=index剪枝掉
        if(visit[i]) continue;
        visit[i]=true;
        temp增加;
        backtrack(i+1,k);
        temp移除;
        visit[i]=false;
        while(i+1<nums.length&&nums[i]==nums[i+1]) i++;//对重复的数字剪枝掉，因为在前面已经试过了
      }
      return false;
      }
      main(){
        Arrays.sort(nums);
        return backtrack(0,k,0);
        return ans;
      }
  }
```
* 剑指 Offer 38. 字符串的排列
输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
## 思路
全排列回溯
```java
class Solution {
    char[] str,temp;
    List<String> ans=new ArrayList<>();
    int length;
    boolean[] visit;
    void backtrack(int index){
        if(index==length){
            ans.add(new String(temp));
            return ;
        }
        for(int i=0;i<length;i++){
            if(visit[i]) continue;
            visit[i]=true;
            temp[index]=str[i];
            backtrack(index+1);
            visit[i]=false;
            while(i+1<length&&str[i]==str[i+1]) i++;
        }
    }
    public String[] permutation(String s) {
        length=s.length();
        if(length==0) return new String[0];
        visit=new boolean[length];
        temp=new char[length];
        str=s.toCharArray();
        Arrays.sort(str);
        backtrack(0);
        return (String[])ans.toArray(new String[0]);
    }
}
```

* 698. 划分为k个相等的子集.md
## 题目

给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。

## 思路
数字全排列，注意枝剪
```java
class Solution {
    int sum;
    int[] nums;
    boolean[] visit;
    boolean backtrack(int all,int k,int index){
        if(all==sum){
            if(k==1) return true;
            if(backtrack(0,k-1,0)) return true;
        } 
        if(all>sum) return false;
        for(int i=index;i<nums.length;i++){
            if(visit[i]) continue;
            visit[i]=true;
            if(backtrack(all+nums[i],k,i+1)) return true;
            visit[i]=false;
            while(i+1<nums.length&&nums[i]==nums[i+1]) i++;
        }
        return false;
    }
    public boolean canPartitionKSubsets(int[] nums, int k) {
        sum=0;
        Arrays.sort(nums);
        this.nums=nums;
        visit=new boolean[nums.length];
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }
        if(sum%k!=0) return false;
        sum/=k;
        return backtrack(0,k,0);
    }
}
```
