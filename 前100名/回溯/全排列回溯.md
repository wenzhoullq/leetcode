## 模板
```java
  void backtrack(){
      if(满足条件){
        增加;
        return;
      }
      for(int i=0;i<nums.length;i++){
        if(visit[i]) continue;
        visit[i]=true;
        temp增加;
        backtrack(i+1);
        temp移除;
        visit[i]=false;
      }
      main(){
        backtrack();
        return ans;
      }
  }
```
全排列的题目主要体现在for(int i=0) 是从头开始的，同时为了避免重复，增加一个visit数组
* 剑指 Offer 38. 字符串的排列


输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
## 思路
全排列回溯
```java
class Solution {
    char[] str,temp;
    ArrayList<String> list=new ArrayList<>();
    boolean[] visit;
    HashSet<String> s=new HashSet<>();
    void flashback(int index){
        if(index==str.length){
            String ss=new String(temp);
            if(!s.contains(ss)){
                list.add(ss);
                s.add(ss);
            }
            return ;
        }
        for(int i=0;i<str.length;i++){
            if(visit[i]) continue;
            visit[i]=true;
            temp[index]=str[i];
            flashback(index+1);
            visit[i]=false;
        }
    }
    public String[] permutation(String s) {
        visit=new boolean[s.length()];
        temp=new char[s.length()];
        str=s.toCharArray();
        flashback(0);
        return list.toArray(new String[list.size()]);
    }
}
```
