### 核心思想

关键在于Arrays.equals(int[] ,int[])，字母都是相同时候，数组相同；或则转换为char[]，char[]可以直接sort,再转化为String加入到Map;

* 49.字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        LinkedList<LinkedList<String>> ans=new LinkedList<>();
        HashMap<String,List<String>> m=new HashMap<>();
        for(int i=0;i<strs.length;i++){
            char[] temp=strs[i].toCharArray();
            Arrays.sort(temp);
            String s=new String(temp);
            if(m.containsKey(s)) m.get(s).add(strs[i]);
            else {
                m.put(s,new LinkedList<String>());
                m.get(s).add(strs[i]);
            }
        }
        return new ArrayList<List<String>>(m.values());
    }
}
```
* 438.找到字符串中所有字母异位词

##### 题目
给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。

##### 思路
`滑动窗口`思想，最简单的滑动窗口，起始点变化就是i++,然后用Arrays.equals()即可

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] temp=new int[26],target=new int[26];
        List<Integer> ans=new LinkedList<Integer>();
        if(p.length()>s.length()) return ans;
        for(int i=0;i<p.length();i++) {
            target[p.charAt(i)-'a']++;
            temp[s.charAt(i)-'a']++;
        }
        if(Arrays.equals(target,temp)) ans.add(0);
        for(int i=p.length();i<s.length();i++){
            temp[s.charAt(i-p.length())-'a']--;
            temp[s.charAt(i)-'a']++;
            if(Arrays.equals(target,temp)) ans.add(i-p.length()+1);
        }
        return ans;
    }
}
```
