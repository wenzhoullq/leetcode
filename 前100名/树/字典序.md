## 模板
本质是一棵树

* 386.字典序排数

## 题目
给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。
## 思路
dfs遍历
```java
class Solution {
    List<Integer> ans=new LinkedList<>();
    int n;
    public List<Integer> lexicalOrder(int n) {
        this.n=n;
        for(int i=1;i<10;i++){
            dfs(i);
        }
        return ans;
    }
    void dfs(int i){
        if(i>n) return ;
        ans.add(i);
        for(int j=0;j<10;j++){
            dfs(i*10+j);
        }
    }
}
```
* 440. 字典序的第K小数字

## 题目
给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
## 思路
普通的dfs时间超时，需要枝剪
```java
```
