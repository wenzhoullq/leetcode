* 105.从前序与中序遍历序列构造二叉树
## 题目

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

## 思路

通过递归来找二叉树，中序遍历通过存储HashMap快速找到下标，然后先序遍历容易找到根节点，中序遍历容易找到左右子树，通过这个性质来递归建立

```java
class Solution {
    HashMap<Integer,Integer> m=new HashMap<>();
    int[] preorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder=preorder;
        for(int i=0;i<inorder.length;i++) m.put(inorder[i],i);
        return rebuild(0,0,preorder.length-1);
    }
    TreeNode rebuild(int root,int left,int right){//这三个参数非常有意思，root是根节点在先序遍历中的位置，left是在中序遍历中左子树起点的位置，right是在中序遍历中右子树终点的位置,如何记忆这三个参数是指什么呢，可以这么思考，先序遍历知道根节点，所以root是指先序中的根节点；中序遍历知道左子树起点和右子树起点，所以left和right是中序中的左起点和右起点
        if(left>right) return null;
        TreeNode node=new TreeNode(preorder[root]);
        int orderroot=m.get(preorder[root]);
        node.left=rebuild(root+1,left,orderroot-1);
        node.right=rebuild(root+orderroot+1-left,orderroot+1,right);
        //右子树的根节点是在上一个根节点加左子树的长度
        return node;
    }
}
```
* 106.从中序与后序遍历序列构造二叉树
## 题目
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
## 思路
把所有变量带进去即可
```java
class Solution {
    int[] inorder,postorder;
    HashMap<Integer,Integer> m;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder=inorder;
        this.postorder=postorder;
        m=new HashMap<Integer,Integer>();
        for(int i=0;i<postorder.length;i++) m.put(inorder[i],i);
        return build(0,inorder.length-1,0,postorder.length-1);
    }
    TreeNode build(int inleft,int inright,int postleft,int postright){
        if(postleft>postright||inleft>inright||postleft<0) return null;
        TreeNode root=new TreeNode(postorder[postright]);
        int index=m.get(postorder[postright]),length=index-inleft;
        TreeNode left=build(inleft,index-1,postleft,postleft+length-1);
        TreeNode right=build(index+1,inright,postleft+length,postright-1);
        root.left=left;
        root.right=right;
        return root;
    }
}
```
