## 题目
你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
## 思路
因为是取**最短路径长**，因此是宽度优先
```java
class Solution {
    public int openLock(String[] deadends, String target) {
        Queue<String> q=new LinkedList<>();
        HashSet<String> s=new HashSet<>();
        for(String num:deadends){
            if(num=="0000") return -1;
            s.add(num); 
        }
        q.add("0000");
        int step=0;
        while(!q.isEmpty()){
            int length=q.size();
            for(int i=0;i<length;i++){
                String temp= q.poll();
                if(temp.equals(target)) return step;
                if(s.contains(temp)) continue;
                s.add(temp);
                for(int j=0;j<4;j++){
                    String prestr=pre(temp,j),nextstr=next(temp,j);
                    if(!s.contains(prestr))q.add(prestr);
                    if(!s.contains(nextstr))q.add(nextstr);
                }
            }
            step++;
        }
        return -1;
    }
    String pre(String str,int i){
        char[] s=str.toCharArray();
        if(s[i]-1<'0') s[i]='9';
        else s[i]=(char)(s[i]-1);
        return new String(s);
    }
     String next(String str,int i){
        char[] s=str.toCharArray();
        if(s[i]+1>'9') s[i]='0';
        else s[i]=(char)(s[i]+1);
        return new String(s);
    }
}
```
