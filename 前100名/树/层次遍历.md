*  102.二叉树的层序遍历

#####  题目
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

##### 思路

基本的层次遍历，但因为输出格式，因此每一层遍历需要记录队列长度

```java
class Solution {
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans =new ArrayList<List<Integer>>();// List初始化必须得ArrayList,LinkedList不行
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        if(root==null) return ans;
        q.offer(root);
        while(!q.isEmpty()){
            int length=q.size();
            LinkedList<Integer> list=new LinkedList<>();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null)q.offer(temp.left);
                if(temp.right!=null)q.offer(temp.right);
                list.add(temp.val);
            }
            ans.add(list);
        }
        return ans;
    }
}
```
*  199.二叉树的右视图
#### 题目
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
#### 思路
层次遍历取最右值
```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> ans=new LinkedList<>();
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        if(root!=null) q.add(root);
        while(!q.isEmpty()){
            int length=q.size();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null) q.add(temp.left);
                if(temp.right!=null) q.add(temp.right);
                if(i==length-1) ans.add(temp.val);
            }
        }
        return ans;
    }
}
```
*  103.二叉树的锯齿形层序遍历
#### 题目
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

#### 思路

遇到奇数层正常插入，遇到偶数层头插

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
      List<List<Integer>> ans=new LinkedList<List<Integer>>();
      if(root==null) return ans;
      Queue<TreeNode> q=new LinkedList<TreeNode>();
      q.add(root);
      int count=0;
      while(!q.isEmpty()){
          LinkedList<Integer> temp=new LinkedList<>();
          TreeNode tempnode;
          int length=q.size();
          for(int i=0;i<length;i++){
              tempnode=q.poll();
              if(count%2==0)temp.add(tempnode.val);
              else temp.addFirst(tempnode.val);
              if(tempnode.left!=null) q.add(tempnode.left);
              if(tempnode.right!=null) q.add(tempnode.right);
          }
          ans.add(temp);
          count++;
      }  
      return ans;
    }
}
```
*  662. 二叉树最大宽度
#### 题目
给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。

#### 思路

层次遍历，把节点的值用来存储节点所在的位置，这个节点的位置注意以下怎么计算

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        LinkedList<TreeNode> q=new LinkedList<TreeNode>();
        int ans=0;
        if(root!=null){
            root.val=0;
            q.add(root);
        } 
        while(!q.isEmpty()){
            int length=q.size(),width=q.getLast().val-q.getFirst().val+1;
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null){
                    temp.left.val=temp.val*2+1;
                    q.add(temp.left);
                }
                if(temp.right!=null){
                    temp.right.val=temp.val*2+2;
                    q.add(temp.right);
                }
            }
            ans=Math.max(ans,width);
        }
        return ans;
    }
}
```
