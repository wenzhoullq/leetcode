  
## 题目
翻转一棵二叉树。
## 思路
递归翻转
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode right=invertTree(root.right);
        TreeNode left=invertTree(root.left);
        root.left=right;
        root.right=left;
        return root;
    }
}
```
本质上还是**二叉树的遍历**，迭代翻转，要么用dfs设立两个栈，然后一个用来遍历，一个用来翻转;要么用BFS，用队列翻转
dfs翻转
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        TreeNode ans=root;
        Stack<TreeNode> s=new Stack<>();
        Stack<TreeNode> rever=new Stack<>();
        while(root!=null||!s.isEmpty()){
            while(root!=null){
                s.push(root);
                root=root.left;
            }
            root=s.pop();
            rever.push(root);
            root=root.right;
        }
        while(!rever.isEmpty()){
            root=rever.pop();
            TreeNode temp=root.right;
            root.right=root.left;
            root.left=temp;
        }
        return ans;
    }
}
```
BFS翻转
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        Queue<TreeNode> q=new LinkedList<>();
        if(root!=null) q.add(root);
        while(!q.isEmpty()){
            int length=q.size();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll(),left=temp.left,right=temp.right;
                temp.left=right;
                temp.right=left;
                if(left!=null) q.add(left);
                if(right!=null) q.add(right);
            }
        }
        return root;
    }
}
```
