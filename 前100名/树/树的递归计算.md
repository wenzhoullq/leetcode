## 模板
```java
    int 递归(){
        if(root==null) return 0;
        int left=递归调用左子树；
        int right=递归调用右子树；
        ans= 根据题目要求；
        return 根据题目要求递归相应的内容;
    }
    mian(){
        
    }
```
*  104.二叉树的最大深度
##### 题目

给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。

##### 思路 
递归调用

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        int left=maxDepth(root.left)+1;
        int right=maxDepth(root.right)+1;
        return Math.max(left,right);
}
}
```
* 124.二叉树中的最大路径和

##### 题目

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。

##### 思路 
咋看看不出来，实质上是递归调用，但是在记录最大值和返回的时候需要注意

```java
class Solution {
    int ans=Integer.MIN_VALUE;
    int dfs(TreeNode root){
        if(root==null) return 0;
        int left=Math.max(dfs(root.left),0);
        int right=Math.max(dfs(root.right),0);
        ans=Math.max(ans,left+right+root.val);//因为部分的时候可能就是最优解了，需要记录
        return root.val+Math.max(left,right);//返回的时候只能返回左右子树中的最大值，不然不能访问了,这个是难点
    }
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }
}
```
* 543.二叉树的直径
##### 题目
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

##### 思路 
经典递归访问高度题，访问到叶节点就返回0，同时记录一个全局变量记录最大值
```java
class Solution {
    int max=0;
    int dfs(TreeNode root){
        if(root==null){
            return 0;
        } 
        intleft=dfs(root.left)+1;
        int right=dfs(root.right)+1;
        max=Math.max(left+right,max);
        return Math.max(left,right);
    }
    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return max;
    }
}
```
* 617.合并二叉树
##### 题目
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

##### 思路
类似于之前的递归计算，但有细节上的不同，问题不大
```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        else if(root2==null) return root1;
        root1.left=mergeTrees(root1.left,root2.left);
        root1.right=mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```
