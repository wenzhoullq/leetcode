*  102.二叉树的层序遍历

#####  题目
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

##### 思路

基本的层次遍历，但因为输出格式，因此每一层遍历需要记录队列长度

```java
class Solution {
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans =new ArrayList<List<Integer>>();// List初始化必须得ArrayList,LinkedList不行
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        if(root==null) return ans;
        q.offer(root);
        while(!q.isEmpty()){
            int length=q.size();
            LinkedList<Integer> list=new LinkedList<>();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null)q.offer(temp.left);
                if(temp.right!=null)q.offer(temp.right);
                list.add(temp.val);
            }
            ans.add(list);
        }
        return ans;
    }
}
```
*  94.二叉树的中序遍历

##### 题目
给定一个二叉树的根节点 root ，返回它的 中序 遍历。

##### 思路
中序遍历

```java
class Solution {
    List<Integer> ans=new LinkedList<Integer>();
    void zhongxu(TreeNode root){
        if(root==null) return ;
        zhongxu(root.left);
        ans.add(root.val);
        zhongxu(root.right);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        zhongxu(root);
        return ans;
    }
}
```
*  98.验证二叉搜索树

##### 题目
验证二叉树

##### 思路
深度优先法
 
```java
class Solution {
    long min=Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        boolean left=isValidBST(root.left);
        if(min>=root.val) return false;
        min=root.val;
        boolean right=isValidBST(root.right);
        return left&&right;
    }
}
```
