*  102.二叉树的层序遍历

#####  题目
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

##### 思路

基本的层次遍历，但因为输出格式，因此每一层遍历需要记录队列长度

```java
class Solution {
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans =new ArrayList<List<Integer>>();// List初始化必须得ArrayList,LinkedList不行
        Queue<TreeNode> q=new LinkedList<TreeNode>();
        if(root==null) return ans;
        q.offer(root);
        while(!q.isEmpty()){
            int length=q.size();
            LinkedList<Integer> list=new LinkedList<>();
            for(int i=0;i<length;i++){
                TreeNode temp=q.poll();
                if(temp.left!=null)q.offer(temp.left);
                if(temp.right!=null)q.offer(temp.right);
                list.add(temp.val);
            }
            ans.add(list);
        }
        return ans;
    }
}
```
*  103.二叉树的锯齿形层序遍历
#### 题目
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

#### 思路

遇到奇数层正常插入，遇到偶数层头插

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
      List<List<Integer>> ans=new LinkedList<List<Integer>>();
      if(root==null) return ans;
      Queue<TreeNode> q=new LinkedList<TreeNode>();
      q.add(root);
      int count=0;
      while(!q.isEmpty()){
          LinkedList<Integer> temp=new LinkedList<>();
          TreeNode tempnode;
          int length=q.size();
          for(int i=0;i<length;i++){
              tempnode=q.poll();
              if(count%2==0)temp.add(tempnode.val);
              else temp.addFirst(tempnode.val);
              if(tempnode.left!=null) q.add(tempnode.left);
              if(tempnode.right!=null) q.add(tempnode.right);
          }
          ans.add(temp);
          count++;
      }  
      return ans;
    }
}
```



*  94.二叉树的中序遍历

##### 题目
给定一个二叉树的根节点 root ，返回它的 中序 遍历。

##### 思路
中序遍历

```java
class Solution {
    List<Integer> ans=new LinkedList<Integer>();
    void zhongxu(TreeNode root){
        if(root==null) return ;
        zhongxu(root.left);
        ans.add(root.val);
        zhongxu(root.right);
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        zhongxu(root);
        return ans;
    }
}
```
*  98.验证二叉搜索树

##### 题目
验证二叉树

##### 思路
深度优先法
 
```java
class Solution {
    long min=Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        boolean left=isValidBST(root.left);
        if(min>=root.val) return false;
        min=root.val;
        boolean right=isValidBST(root.right);
        return left&&right;
    }
}
```
