	

模板
===

```java
boolean panding (Tree left,Tree right){
	if(left==null&&right==null) return true;
	if(不满足) return false;
	return panding(左子树)&&panding(右子树）
}
主函数{
	return panding(根节点)
}
```

* 98.验证二叉搜索树
##### 题目

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树

##### 思路

判断二叉树有两种思路，一种是中序遍历，中序遍历后是一个升序；另一个是递归，左子树的val小于父节点，右子树的val大于父节点，那么设定一个父节点的值就是左子树的上限，右子树的下限

```java
class Solution {
    boolean zhongxu(TreeNode root,long low, long hight){
        if(root==null) return true;
        if(root.val<=low||root.val>=hight) return false;
        return zhongxu(root.left,low,root.val)&&zhongxu(root.right,root.val,hight);
    }
    public boolean isValidBST(TreeNode root) {
        return zhongxu(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
}
```
* 101 对称二叉树

##### 题目

给定一个二叉树，检查它是否是镜像对称的。

##### 思路

模板套用

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    boolean same(TreeNode left,TreeNode right){
        if(left==null&&right==null) return true;
        if((left==null&&right!=null)||(left!=null&&right==null)) return false;
        if(left.val!=right.val) return false;
        return same(left.left,right.right)&&same(left.right,right.left);
    }
    public boolean isSymmetric(TreeNode root) {
        return same(root.left,root.right);
    }
}
```
