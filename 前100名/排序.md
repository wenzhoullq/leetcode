## 快排
### 左右指针法
```java
     void quicksort(int left,int right){
        if(left>=right) return ;
        int i=left,j=right,pri=nums[i];
        while(i<j){
          while(i<j&&nums[j]>pri) j--;
          while(i<j&&nums[i]<=pri) i++;
          if(i<j) {
              int temp=nums[i];
              nums[i]=nums[j];
              nums[j]=temp;
          }
    }
        int temp=nums[i];
        nums[i]=nums[left];
        nums[left]=temp;
        quicksort(left,i-1);
        quicksort(i+1,right);
        return ;
    }
```
### 挖坑法
```java
     void quicksort(int left,int right){
        if(left>=right) return ;
        int i=left,j=right,pri=nums[i];
        while(i<j){
          while(i<j&&nums[j]>=pri) j--;
          if(i<j)  nums[i]=nums[j];
          while(i<j&&nums[i]<=pri) i++;
          if(i<j)  nums[j]=nums[i];
        }
        nums[i]=pri;
        quicksort(left,i-1);
        quicksort(i+1,right);
        return ;
    }
```
* 相同点
 都是先移动右指针，再移动左指针:因为在i指向的值退出循环的时候要**小于等于基准值**，保证基准值归位的时候是正确的;
* 不同点 
1.在取等号上有所不同，第一版的在左指针处取了等号，可以这么思考：如果左指针不取等号的话，那么在第一个**自己和自己的比较**时候就无法移动指针了
2.在值交换上不同，一个是值进行交换，另一个是直接覆盖
快慢指针版
```java
public int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        int smaller_tail_index = left;
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < pivot) {
                smaller_tail_index++;
                swap(nums, smaller_tail_index, i);
            }
        }
        swap(nums, smaller_tail_index, left);
        return smaller_tail_index;
    }
```
原理和双指针版相同，只不过左右指针改为快慢指针
快慢指针和左右指针都有相同的点，在基准值上都取首个，快排想要速度排快的话，必须在划分子列的时候是均匀的，如果是极端情况（本来就是顺序的队列），那么必然导致树的左右两端不平衡，
将时间复杂度变为O(n²)
显而易见，问题出自基准的选择，因此有如下修正方式
* 1.随机选择基准值
运用Random算法，在基准值的选择上变为随机选择，可以增大恰好选择中间值的概率，但**不能避免选择到最大值和最小值**
`int random_index = new Random().nextInt(right - left + 1) + left;
        swap(nums, random_index, left);
`
* 2. 三数取中法
即在left，right和（left+right）/2中选择中间值，那么可以避免选择到最值，但是仍不能排除一个重复序列，如最值都是1，恰好排在left，right,（left+right）/2中

其他的优化方法，如设置阈值，如果排列的长度小于某个阈值，则选择插入排序，大大减少时间复杂度。

* 时间复杂度
时间复杂度主要由选择的基准值是否能将队列均匀划分，如果能够均匀划分，那么最后的时间复杂度为O(nlogn);反之则变为O(n²)

### 非递归版快排
递归本质上就是栈，非递归就是设置一个栈，只要栈不为空，每次都会取出一对左右边界，然后对左右边界进行快排。
## 归并
归并需要注意的是归并是分割到最小后合并，并且合并后的结果是新增的跟原来的无关
* 23.合并K个升序链表
给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。
```java
class Solution {
    ListNode[] lists;
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return null;
        this.lists=lists;
        return mergeList(0,lists.length-1);
    }
    ListNode mergeList(int head,int tail){
        if(head>=tail) return lists[head];
        ListNode left=mergeList(head,(head+tail)/2),right=mergeList((head+tail)/2+1,tail);
        return merge(left,right);
    }
    ListNode merge(ListNode l1,ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val>l2.val){
            l2.next=merge(l1,l2.next);
            return l2;
        }
        else{
            l1.next=merge(l1.next,l2);
            return l1;
        }
    }
}
```
* 148.排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
## 思路
因为是链表的排序，因此要将中间的断开
```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode p=head;
        while(p.next!=null) p=p.next;
        return mergetsort(head,p);
    }
    ListNode mergetsort(ListNode head,ListNode tail){
        if(head==tail||head==null)  return head;
        ListNode mid=findmid(head),temp=mid.next;
        mid.next=null;
        ListNode left=mergetsort(head,mid),right=mergetsort(temp,tail);
        return  mergetList(left,right);
        
    }
    ListNode mergetList(ListNode l1,ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val>l2.val){
            l2.next=mergetList(l1,l2.next);
            return l2;
        }
        else{
            l1.next=mergetList(l1.next,l2);
            return l1;
        }
    }
    ListNode findmid(ListNode head){
        ListNode dummy=new ListNode(0,head),quick=dummy,slow=dummy;
        while(quick!=null&&quick.next!=null){
            quick=quick.next.next;
            slow=slow.next;
        }
        return slow;
    }
}
```
* 剑指 Offer51.数组中的逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
## 思路
逆序对在归并排序的时候会出现
```java
class Solution {
    int[] nums;
    int merge(int left,int right){
        if(left>=right) return 0;
        int[] temp=new int[right-left+1];
        int ans=0,mid=(left+right)/2,i=left,j=mid+1,index=0;
        ans+=merge(left,mid);
        ans+=merge(mid+1,right);
        while(i<=mid&&j<=right){
            if(nums[i]>nums[j]) {
                temp[index++]=nums[j++];
                ans+=mid-i+1;//计算逆序对的个数
            }
            else {
                temp[index++]=nums[i++];
            }
        }
        while(i<=mid){
            temp[index++]=nums[i++];
        }
        while(j<=right){
            temp[index++]=nums[j++];
            
        }
        for(index=left;index<=right;index++){
            nums[index]=temp[index-left];
        }
        return ans;
    }
    public int reversePairs(int[] nums) {
        this.nums=nums;
        // merge(0,nums.length-1);
        // return nums[2];
        return merge(0,nums.length-1);
    }
}
```
