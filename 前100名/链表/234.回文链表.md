## 题目

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

## 思路

最垃圾的想法是用栈，但是这里用双指针，首先用快慢指针找到中点，在找中点时同时将之前的节点的.next改变方向，到了中点之后开始对比

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null) return true;
        ListNode slow=head,quick=head,pre=null;
        while(quick!=null&&quick.next!=null){
            quick=quick.next.next;
            ListNode temp=slow.next;
            slow.next=pre;//改变节点方向
            pre=slow;
            slow=temp;
        }
        if(quick!=null) slow=slow.next;//链表长度奇偶数的判定
        while(slow!=null||pre!=null){
            if(slow.val!=pre.val) return false;
            slow=slow.next;
            pre=pre.next;
        }
        return true;
    }
}
```

空间复杂度O(1)用头插法改变后半部分的方向
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode dummy=new ListNode(1,head),quick=dummy,slow=dummy;
        while(quick!=null&&quick.next!=null){
            quick=quick.next.next;
            slow=slow.next;
        }
        ListNode dummy1=new ListNode(1);
        quick=head;
        while(slow!=null){
            ListNode temp=slow.next;
            slow.next=dummy1.next;
            dummy1.next=slow;
            slow=temp;
        }
        slow=dummy1.next;
        while(quick!=null){
            if(slow.val!=quick.val) return false;
            slow=slow.next;
            quick=quick.next;
        }
        return true;
    }
}
```



