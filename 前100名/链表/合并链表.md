升序链表合并
=
## 思路
升序链表合并的经典`递归模板`，对于两条链表效率比较高，但是对于多条链表的话，效率比较低，应该采用`分治法`

* 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
       if(l1==null) return l2;
       if(l2==null) return l1;
       if(l1.val<l2.val)
       {
           l1.next=mergeTwoLists(l1.next,l2);
           return l1;
       }
       else {
           l2.next=mergeTwoLists(l2.next,l1);
           return l2;
       }
    }
}
```
        这个是链表合并的经典模板
* 23.合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

#### 法一
经典升序链表合并模板
```java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ListNode ans;
    ListNode merge(ListNode l1,ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next=merge(l1.next,l2);
            return l1;
        }
        else {
            l2.next=merge(l2.next,l1);
            return l2;
        }
    }
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return ans;
        if(lists.length==1) return lists[0];
        ans=lists[0];
       for(int i=1;i<lists.length;i++){
           ans=merge(ans,lists[i]);
       } 
       return ans;
    }
}
```
