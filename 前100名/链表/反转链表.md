在链表题中，思路分为**迭代**和**递归**，其中迭代有两种方式，一是**快慢指针**，二是头插法；递归则是递归访问至**链表末端**，一直记着末端，然后对cur不断重新指向。
* 206.反转链表.md
## 题目
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
## 备注
考察最多的题目，大部分公司以**迭代法要求居多**，**但是**可能会出现需要你**同时掌握**迭代和递归，如字节跳动
## 思路 
解一：快慢指针
```java
class Solution {
    public ListNode reverseList(ListNode head) {
            ListNode pre=null,cur=head,temp;
            while(cur!=null){
                temp=cur.next;
                cur.next=pre;
                pre=cur;
                cur=temp;
            }
            return pre;
    }
}
```
解二：头插法 推荐
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null) return head;
        ListNode dummy=new ListNode(0,head),cur=head;
        while(cur.next!=null) {
            ListNode temp=cur.next;
            cur.next=cur.next.next;
            temp.next=dummy.next;
            dummy.next=temp;
        }
        return dummy.next;
    }
}
```
解三：递归法
在递归法中，递归到的尾节点是最后的**输出节点**，最后的链表的指向的改变还是通过**head节点**进行处理。
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode temp=reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return temp;
    }
}
```
* 92.反转链表 II.md
## 题目
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
## 思路
206.反转链表的变形题，因为链表尾端不是null，所以具体出现差别，注意细节
解一 头插法
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy=new ListNode(1,head);
        ListNode start=dummy,cur=head;
        for(int i=0;i<left-1;i++){
            start=start.next;
            cur=cur.next;
        }
        for(int i=0;i<right-left;i++){
            ListNode temp=cur.next;
            cur.next=cur.next.next;//与206.反转链表的头插法不同的是，**这里是对cur.next不断移动，但同时cur是不会移动的**
            temp.next=start.next;
            start.next=temp;
        }
        return dummy.next;
    }
}
```
解二 递归法
```java
class Solution {
    int right;
    ListNode rear;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        this.right=right;
        ListNode dummy=new ListNode(0,head),p=dummy;
        for(int i=0;i<left-1;i++)  p=p.next;
        p.next=reverse(p.next,left);
        return dummy.next;
    }
    ListNode reverse(ListNode head,int index){//与206.反转链表的递归思想相似，只是尾指针处理不同
        if(index==right) {
            rear=head.next;
            return head;
        }
        ListNode temp=reverse(head.next,index+1);
        head.next.next=head;
        head.next=rear;
        return temp;
    }
}
```
* 25.K 个一组翻转链表
## 题目
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：

你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
## 备注
高频题，92的变形题，要求使用头插法，这里仅展示头插法
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy=new ListNode(0,head),p=head;
        int count=0;
        while(p!=null){
            p=p.next;
            count++;
        }
        ListNode pre=dummy,cur=head;
        while(count-k>=0){
            count-=k;
            int num=0;
            while(num<k-1){
                ListNode temp=cur.next;
                cur.next=cur.next.next;
                temp.next=pre.next;
                pre.next=temp;
                num++;
            }
            pre=cur;
            cur=cur.next;
        }
        return dummy.next;
    }
}
```
* 61.旋转链表
## 题目
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
## 思路
三次翻转链表,注意K的处理
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null||head.next==null) return head;
        ListNode p=head;
        int length=0;
        while(p!=null) {
            p=p.next;
            length++;
        }
        if(k%length==0) return head;
        k%=length;
        ListNode l1=reverse(head);
        p=l1;
        for(int i=0;i<k-1;i++){
            p=p.next;
        }
        ListNode q=p;
        p=p.next;
        q.next=null;
        ListNode l2=reverse(l1),l3=reverse(p);
        l1.next=l3;
        return l2;
    }
    ListNode reverse(ListNode head){
        if(head==null||head.next==null) return head;
        ListNode dummy=new ListNode(0,head),p=head;   
        while(p.next!=null){
            ListNode temp=p.next.next;
            p.next.next=dummy.next;
            dummy.next=p.next;
            p.next=temp;
        }
        return dummy.next;
    }
}
```
