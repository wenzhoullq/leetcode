在链表题中，思路分为**迭代**和**递归**，其中迭代有两种方式，一是**快慢指针**，二是头插法；递归则是递归访问至**链表末端**，一直记着末端，然后对cur不断重新指向。
* 206.反转链表.md
## 题目
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
## 备注
考察最多的题目，大部分公司以**迭代法要求居多**，**但是**可能会出现需要你**同时掌握**迭代和递归，如字节跳动
## 思路 
解一：快慢指针
```java
class Solution {
    public ListNode reverseList(ListNode head) {
            ListNode pre=null,cur=head,temp;
            while(cur!=null){
                temp=cur.next;
                cur.next=pre;
                pre=cur;
                cur=temp;
            }
            return pre;
    }
}
```
解二：头插法
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummy=new ListNode(),p=head;
        while(p!=null){
            ListNode temp=p.next;
            p.next=dummy.next;
            dummy.next=p;
            p=temp;
        }
        return dummy.next;
    }
}
```
解三：递归法
在递归法中，递归到的尾节点是最后的**输出节点**，最后的链表的指向的改变还是通过**head节点**进行处理。
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode temp=reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return temp;
    }
}
```
* 92.反转链表 II.md

解一 头插法
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy=new ListNode(1,head);
        ListNode start=dummy,cur=head;
        for(int i=0;i<left-1;i++){
            start=start.next;
            cur=cur.next;
        }
        for(int i=0;i<right-left;i++){
            ListNode temp=cur.next;
            cur.next=cur.next.next;//与206.反转链表的头插法不同的是，**这里是对cur.next不断移动，但同时cur是不会移动的**
            temp.next=start.next;
            start.next=temp;
        }
        return dummy.next;
    }
}
```
解二 递归法
```java
class Solution {
    int right;
    ListNode rear;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        this.right=right;
        ListNode dummy=new ListNode(0,head),p=dummy;
        for(int i=0;i<left-1;i++)  p=p.next;
        p.next=reverse(p.next,left);
        return dummy.next;
    }
    ListNode reverse(ListNode head,int index){//与206.反转链表的递归思想相似，只是尾指针处理不同
        if(index==right) {
            rear=head.next;
            return head;
        }
        ListNode temp=reverse(head.next,index+1);
        head.next.next=head;
        head.next=rear;
        return temp;
    }
}
```
