##### 思路
当求`某一段的和`的时候，可以通过`当前的前缀和-历史出现过的前缀和`判断中间是否存在符合题意的和,前缀和适合`求个数`
##### 模板
```java
	HashMap<Integer,Integer> m;
	main(){
	int temp=0,ans=0；
	m.put(0,1);//temp-target==0时候需要记录
	for(int i=0;i<nums.length;i++){
	temp+=nums[i];//记录前缀和
	ans+=m.getOrdefault(temp-target,0);//当temp-target,当他出现过之前的前缀和时候，那么这一段就是符合题意
	m.put(temp,m.getOrdefault(temp,0)+1);
}
}
```
*  437.路径总和 III
###### 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
```java
class Solution {
    HashMap<Integer,Integer> m=new HashMap<>();
    int ans=0,target;
    void dfs(TreeNode root,int temp){
        if(root==null) return ;
        temp+=root.val;
        ans+=m.getOrDefault(temp-target,0);
        m.put(temp,m.getOrDefault(temp,0)+1);
        dfs(root.left,temp);
        dfs(root.right,temp);
        m.put(temp,m.getOrDefault(temp,0)-1);
    }
    public int pathSum(TreeNode root, int targetSum) {
        target=targetSum;
        m.put(0,1);
        dfs(root,0);
        return ans;
    }
}
```
*  560.和为 K 的子数组
##### 题目
给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

##### 思路
一开始想用dp,但是太麻烦了，然后用了回溯，超时了，因为是连续的，所以可以用`前缀和`
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int pre=0,ans=0;
        HashMap<Integer,Integer> m=new HashMap<>();
        m.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            ans+=m.getOrDefault(pre-k,0);
            m.put(pre,m.getOrDefault(pre,0)+1);
        }
        return ans;
    }
}
```
