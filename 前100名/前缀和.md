##### 思路
当求`某一段的和`的时候，可以通过`当前的前缀和-历史出现过的前缀和`判断中间是否存在符合题意的和
##### 模板
```java
	HashMap<Integer,Integer> m;
	main(){
	int temp=0,ans=0；
	m.put(0,1);//temp-target==0时候需要记录
	for(int i=0;i<nums.length;i++){
	temp+=nums[i];//记录前缀和
	ans+=m.getOrdefault(temp-target,0);//当temp-target,当他出现过之前的前缀和时候，那么这一段就是符合题意
	m.put(temp,m.getOrdefault(temp,0)+1);
}
}
```
* 437. 路径总和 III
###### 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
```java
class Solution {
    HashMap<Integer,Integer> m=new HashMap<>();
    int ans=0,target;
    void dfs(TreeNode root,int temp){
        if(root==null) return ;
        temp+=root.val;
        ans+=m.getOrDefault(temp-target,0);
        m.put(temp,m.getOrDefault(temp,0)+1);
        dfs(root.left,temp);
        dfs(root.right,temp);
        m.put(temp,m.getOrDefault(temp,0)-1);
    }
    public int pathSum(TreeNode root, int targetSum) {
        target=targetSum;
        m.put(0,1);
        dfs(root,0);
        return ans;
    }
}
```
