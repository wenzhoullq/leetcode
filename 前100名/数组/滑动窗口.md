## 模板
本质是双指针甚至三指针，固定一个left,right指针不断移动，寻找到**满足的**不断对left进行滑动至**极限**,滑动窗口有一个很大的前提，就是**保证所有的数字都是非负的**
```java
int left=0,right=nums.length-1;
  for(int i=0;i<nums.length;i++){
    if(满足条件){
      while(不断移动左指针至不满足)
    }
  }
```
* 239.滑动窗口最大值
## 题目
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。
## 思路
滑动窗口
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> q=new LinkedList<Integer>();
        int[] ans=new int[nums.length-k+1];
        for(int i=0;i<k;i++){
            while(!q.isEmpty()&&nums[q.getLast()]<=nums[i]) q.removeLast();
            q.offer(i);
        }
        for(int i=k;i<nums.length;i++){
            ans[i-k]=nums[q.getFirst()];
            while(!q.isEmpty()&&nums[q.getLast()]<=nums[i]) q.removeLast();
            while(!q.isEmpty()&&i-k+1>q.getFirst()) q.removeFirst();
            q.offer(i);
        }
        ans[nums.length-k]=nums[q.getFirst()];
        return ans;
    }
}
```
* 76.最小覆盖子串
## 题目
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
## 思路
用一个count[]来判定是否满足条件
```java
class Solution {
    public String minWindow(String s, String t) {
        int length1=s.length(),length2=t.length(),all=length2,length=Integer.MAX_VALUE,ansstart=0,tempstart=0;
        if(length1==0||length2==0||length2>length1) return "";
        int[] count=new int[256];
        for(int i=0;i<length2;i++) count[t.charAt(i)]++;
        for(int i=0;i<length1;i++){
            int temp=s.charAt(i);
            if(count[temp]-->0){
                all--;
                if(all==0){
                    while(all==0){
                        temp=s.charAt(tempstart++);
                        count[temp]++;
                        if(count[temp]>0){
                            all++;
                            break;
                        }  
                    }
                    if(i-tempstart+2<length){
                        length=i-tempstart+2;
                        ansstart=tempstart-1;
                    }
                }
            }
        }
        if(length==Integer.MAX_VALUE) return "";
        return s.substring(ansstart,ansstart+length);
    }
}
```
* 209.长度最小的子数组.md
## 题目
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
## 思路
经典滑动窗口思想
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int ans=Integer.MAX_VALUE,temp=0,left=0;
        for(int i=0;i<nums.length;i++){
            temp+=nums[i];
            if(temp>=target){
                while(temp>=target){
                temp-=nums[left];
                left++;
                }
                ans=Math.min(ans,i-left+2);
            }
        }
        return ans==Integer.MAX_VALUE?0:ans;
    }
}
```
