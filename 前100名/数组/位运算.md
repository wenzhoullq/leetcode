



|      |      |                                                              |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数 |
| >>>  | 右移 | 无符号右移动 |
| <<<  | 左移 | 无符号左移动 |

左高位右低位

*  137.只出现一次的数字 II
## 题目
给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
## 思路
 位运算，两次用^,三次挨个算
 ```java
 class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int num : nums) {
            for(int j = 0; j < 32; j++) {
                counts[j] += num & 1;
                num >>>= 1;
            }
        }
        int res = 0, m = 3;
        for(int i = 0; i < 32; i++) {
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}

 ```
 * 260.只出现一次的数字 III

## 题目
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
## 思路
出现两次的可以用^抵消掉，出现一次的进行^肯定至少存在一位是不同的，因此找到那一位不同的，用于分辨那两个数字
```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int test=0,a=0,b=0,num=1;
        for(int i=0;i<nums.length;i++) test^=nums[i];
        while((test&num)==0) num<<=1;
        for(int i=0;i<nums.length;i++){
            if((num&nums[i])==0) a^=nums[i];
            else  b^=nums[i];
        }
        return new int[]{a,b};
    }
}
```
