## 二分
二分法可以查target值，也可以查极值,也可以和左右比较
查找极值分为严格单调和不严格单调，严格单调的用nums[mid]和nums[mid+1]比,不严格单调用nums[right]和nums[mid]比
和左右比较是nums[mid]和nums[mid+1]比较
注：只有不严格单调查极值才会nums[right]进行比较，并且不可能和**nums[left]比较**

## 左边界
如果找不到目标值，结果则是第一个**大于**目标值的数，无论left和right
```java
int l=0,r=nums.length-1;
while(l<r){ //注意这里是<而不是<=
    int mid=(l+r)/2;
    if(target>nums[mid]) l=mid+1; //
    else  r=mid;
}
return nums[l]==target?l:-1;

```

## 右边界
如果找不到目标值，结果则是第一个**小于**目标值的数，无论left和right
```java
int l=0,r=nums.length-1;
while(l<r){ 
    int mid=(l+r+1)/2;
    if(target<nums[mid]) r=mid-1;
    else  l=mid;
}
return nums[r]==target?r:-1;

```
* 69.x的平方根

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
## 思路
二分法右边界
```java
class Solution {
    public int mySqrt(int x) {
        if(x==0||x==1) return x;
        int left=0,right=x/2;
        while(left<right){
            int mid=(left+right+1)/2;
            if(x/mid<mid) right=mid-1;
            else left=mid;
        }
        return left;
    }
}
```

* 34.在排序数组中查找元素的第一个和最后一个位置
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。
## 思路
左边界+右边界
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length==0) return new int[]{-1,-1};
        int[] ans;
        int start=-1,end=-1,l=0,r=nums.length-1,find=-1;
        while(l<r){
            int mid=(l+r)/2;
            if(target<=nums[mid]) r=mid;
            else l=mid+1;
        }
        if(nums[l]!=target)  return new int[]{-1,-1};
        int L=l;
        r=nums.length-1;
        while(L<r){
            int mid=(L+r+1)/2;
            if(target>=nums[mid]) L=mid;
            else r=mid-1;
        }

        return ans=new int[]{l,L};
    }
}
```

* 33.搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

## 思路

旋转数组有一个非常重要的特点，就是取mid, `mid的左边或则右边至少有一边是升序排序的`，基于这个性质，我们去寻找哪一边是升序排序的`nums[left]<nums[mid]`;找到升序排序的部分后，对升序排序
的部分看看target是否在其中，如果是，那么在这个范围内使用二分查找；反之在另一半非升序部分改变查询范围

## 代码

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length==0) return -1;
        int left=0,right=nums.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[right]){
                if(nums[mid]<target&&nums[right]>=target)
                left=mid+1;
                else right=mid;
            }
            else if(nums[mid]>nums[right]) {
                if(nums[mid]>=target&&nums[left]<=target) right=mid;
                else left=mid+1;
            }
            else right--;
        }
    return nums[left]==target?left:-1;
    }
}
```

*  69.Sqrt(x)
## 题目
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
## 思路
右边界的二分法
```java
class Solution {
    public int mySqrt(int x) {
        if(x==0) return 0;
        if(x<4) return 1;
        int left=1,right=x/2;
        while(left<right){
            int mid=(left+right+1)/2;
            if(x/mid<mid) right=mid-1;//用除法而不是乘法防止溢出
            else left=mid;
        }
        return right;
    }
}
```
* 162.寻找峰值
## 题目
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
## 思路
对于严格单调的数组，可以通过二分法找到峰值
```java
class Solution {
    public int findPeakElement(int[] nums) {
       int left=0,right=nums.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[mid+1]) left=mid+1;
            else right=mid;
        }
        return left;
    }
}
```
* 11.旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  
## 思路
对于不严格单调的寻找极值，只能和nums[right]和nums[mid]比较，注意，这里**只能用**nums[right],**不能用**nums[left],因为涉及到重复项的问题
```java
class Solution {
    public int minArray(int[] numbers) {
        int left=0,right=numbers.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(numbers[right]>numbers[mid]) right=mid;
            else if(numbers[right]<numbers[mid]) left=mid+1;
            else right--;
        }
        return numbers[left];
    }
}
```
* 852.山脉数组的峰顶索引

## 题目
符合下列属性的数组 arr 称为 山脉数组 ：
arr.length >= 3
存在 i（0 < i < arr.length - 1）使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。
## 思路
二分找最值
```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int left=0,right=arr.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(arr[mid]<arr[mid+1]) left=mid+1;
            else right=mid;
        }
        return left;
    }
}
```
* 1095.山脉数组中查找目标值
（这是一个 交互式问题 ）

给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。

如果不存在这样的下标 index，就请返回 -1。

 

何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：

首先，A.length >= 3

其次，在 0 < i < A.length - 1 条件下，存在 i 使得：

A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
 

你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：

MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
 
## 思路
先找峰值，再找目标值
```java
class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int left=0,right=mountainArr.length()-1,maxindex=-1;
        while(left<right){
            int mid=(left+right)/2;
            if(mountainArr.get(mid)<mountainArr.get(mid+1)) left=mid+1;
            else right=mid;
        }
        maxindex=left;
        left=0;right=maxindex;
        while(left<right){
            int mid=(left+right)/2;
            if(mountainArr.get(mid)<target) left=mid+1;
            else right=mid;
        }
        if(mountainArr.get(left)==target) return left;
        left=maxindex;right=mountainArr.length()-1;
        while(left<right){
            int mid=(left+right+1)/2;
            if(mountainArr.get(mid)<target) right=mid-1;
            else left=mid;
        }
        return mountainArr.get(right)==target?right:-1;
    }
}
```
* 540.有序数组中的单一元素

## 题目
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
## 思路
从logn中得知必然是二分法，但是如何判断这个二分法呢？首先数组长2n+1，mid值为n,有奇有偶。如果是偶数，和1进行^运算，那么是+1，是和下一个的配对的偶数配对，如果nums[mid]==nums[mid+1],那么右边必然不能配对，因此单次出现必然在右
```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left=0,right=nums.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]==nums[mid^1]) left=mid+1;
            else right=mid;
        }
        return nums[left];
    }
}
```
