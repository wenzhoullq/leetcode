## 二分模板

首先看一个数组  {1，2，2，2，3} ，如果想要查最左边的2，怎么查？最右边的2，怎么查？最直接的思路是普通的二分法，然后查到后通过线性访问，但是时间复杂度是比一般的O(log n)是大一点的，有二分的模板，
可以直接查询左右边界

### 左边界
```java
int l=0,r=nums.length-1;
while(l<r){ //注意这里是<而不是<=
    int mid=(l+r)/2;
    if(target<=nums[mid]) r=mid; //如何记忆这个=号，因为取左边界，因此l肯定是l+1,所以r是r=mid,因为是=号，因此前面必须<=
    else  l=mid+1;
}
return l;

```

### 右边界

```java
int l=0,r=nums.length-1;
while(l<r){ //注意这里是<而不是<=
    int mid=(l+r+1)/2;
    if(target>=nums[mid]) l=mid;
    else  r=mid-1;
}
return l;

```

        没有边界要求的使用左右边界都可以，或则是l<=r版本也可以，左右版本的记忆需要时常复习，不然会忘记
*34.在排序数组中查找元素的第一个和最后一个位置


给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if(nums.length==0) return new int[]{-1,-1};
        int[] ans;
        int start=-1,end=-1,l=0,r=nums.length-1,find=-1;
        while(l<r){
            int mid=(l+r)/2;
            if(target<=nums[mid]) r=mid;
            else l=mid+1;
        }
        if(nums[l]!=target)  return new int[]{-1,-1};
        int L=l;
        r=nums.length-1;
        while(L<r){
            int mid=(L+r+1)/2;
            if(target>=nums[mid]) L=mid;
            else r=mid-1;
        }

        return ans=new int[]{l,L};
    }
}
```

*搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

## 思路

旋转数组有一个非常重要的特点，就是取mid, `mid的左边或则右边至少有一边是升序排序的`，基于这个性质，我们去寻找哪一边是升序排序的`nums[left]<nums[mid]`;找到升序排序的部分后，对升序排序
的部分看看target是否在其中，如果是，那么在这个范围内使用二分查找；反之在另一半非升序部分改变查询范围

## 代码

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length==0) return -1;
        int left=0,right=nums.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[right]){
                if(nums[mid]<target&&nums[right]>=target)
                left=mid+1;
                else right=mid;
            }
            else if(nums[mid]>nums[right]) {
                if(nums[mid]>=target&&nums[left]<=target) right=mid;
                else left=mid+1;
            }
            else right--;
        }
    return nums[left]==target?left:-1;
    }
}
```

*  69.Sqrt(x)
## 题目
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
## 思路
右边界的二分法
```java
class Solution {
    public int mySqrt(int x) {
        if(x==0) return 0;
        if(x<4) return 1;
        int left=1,right=x/2;
        while(left<right){
            int mid=(left+right
            +1)/2;
            if(x/mid<mid) right=mid-1;//用除法而不是乘法防止溢出
            else left=mid;
        }
        return right;
    }
}
```
* 162.寻找峰值
## 题目
峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
## 思路
要求Logn，则是二分法，重点在于比较和移动
```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0,right=nums.length-1;
        while(left<right){
            int mid=(left+right)/2;
            if(nums[mid]<nums[mid+1]) left=mid+1;
            else right=mid;
        }
        return left;
    }
}
```
