## 思路
当求`某一段的和`的时候，可以通过`当前的前缀和-历史出现过的前缀和`判断中间是否存在符合题意的和,即求前缀和。前缀和有两种题型，一种是前缀和的个数，一种是前缀和的长度。前缀和有两种，一种是hashmap的前缀和，一**种是数组的前缀和，HashMap的前缀和可以快速找到下标，适合==target，而数组的前缀和则是适合>target的，如果是**nums[i]都非负数**，用前缀和+滑动窗口即可，如果有非负数，**一定要用数组的前缀和+单调栈**。
## 模板
* 前缀和个数
```java
	HashMap<Integer,Integer> m;
	main(){
	int cur=0,ans=0；
	m.put(0,1);
	for(int i=0;i<nums.length;i++){
	cur+=nums[i];//记录前缀和
	ans+=m.getOrdefault(cur-target,0);//当temp-target,当他出现过之前的前缀和时候，那么这一段就是符合题意
	m.put(temp,m.getOrdefault(temp,0)+1);
}
}
```
* 前缀和长度 
```java
	HashMap<Integer,Integer> m;
	main(){
	int cur=0,length=Max；
	m.put(0,-1);
	for(int i=0;i<nums.length;i++){
	cur+=nums[i];//记录前缀和
	if(m.containsKey(cur-k)) lenth=Math.min(length,i-m.get(cur-k));
	else m.put(cur,i);}
	return length==Max?-1:length;
}
```
*  437.路径总和 III
## 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
```java
class Solution {
    HashMap<Integer,Integer> m=new HashMap<>();
    int ans=0,target;
    void dfs(TreeNode root,int temp){
        if(root==null) return ;
        temp+=root.val;
        ans+=m.getOrDefault(temp-target,0);
        m.put(temp,m.getOrDefault(temp,0)+1);
        dfs(root.left,temp);
        dfs(root.right,temp);
        m.put(temp,m.getOrDefault(temp,0)-1);
    }
    public int pathSum(TreeNode root, int targetSum) {
        target=targetSum;
        m.put(0,1);
        dfs(root,0);
        return ans;
    }
}
```
*  560.和为 K 的子数组
##### 题目
给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

##### 思路
一开始想用dp,但是太麻烦了，然后用了回溯，超时了，因为是连续的，所以可以用`前缀和`
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int pre=0,ans=0;
        HashMap<Integer,Integer> m=new HashMap<>();
        m.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            ans+=m.getOrDefault(pre-k,0);
            m.put(pre,m.getOrDefault(pre,0)+1);
        }
        return ans;
    }
}
```
* 862. 和至少为 K 的最短子数组

## 题目
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。
## 思路
**因为nums[i]有非负数**，因此是数组形式的前缀和＋单调栈
```java
class Solution {
    public int shortestSubarray(int[] nums, int k) {
        int length=Integer.MAX_VALUE;
        long[] A=new long[nums.length+1];
        for(int i=0;i<nums.length;i++){
            if(nums[i]>=k) return 1;
            A[i+1]=A[i]+nums[i];
        }
        Deque<Integer> q=new LinkedList<Integer>();
        for(int i=0;i<A.length;i++){
            while(!q.isEmpty()&&A[i]<=A[q.getLast()]){
                q.removeLast();
            }
            while(!q.isEmpty()&&A[i]-A[q.getFirst()]>=k){
                length=Math.min(length,i-q.getFirst());
                q.removeFirst();
            }
            q.add(i);
        }
        return length==Integer.MAX_VALUE?-1:length;
    }
}
```
* 974.和可被 K 整除的子数组

## 题目
给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的（连续、非空） 子数组 的数目。

子数组 是数组的 连续 部分。
## 思路
因为带负数，余同定理前缀和
```java
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        HashMap<Integer,Integer> m=new HashMap<>();
        m.put(0,1);
        int pre=0,ans=0;
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            int num=((pre%k)+k)%k, n=m.getOrDefault(num,0);
            ans+=n;   
            m.put(num,n+1);
        }
        return ans;
    }
}
```
* 538. 连续的子数组和

## 题目
给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

 
## 思路
倍数的前缀和，注意初始化m.put(0,-1)
```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int pre=0;
        HashMap<Integer,Integer> m=new HashMap<>();
        m.put(0,-1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            int index=pre%k;
            if(m.containsKey(index)&&i-m.get(index)>1) return true;
            if(!m.containsKey(index))m.put(index,i);
        }
        return false;
    }
}
```
