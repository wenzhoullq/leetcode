## 思路
当求`某一段的和`的时候，可以通过`当前的前缀和-历史出现过的前缀和`判断中间是否存在符合题意的和,即求前缀和。前缀和有两种题型，一种是前缀和的个数，一种是前缀和的长度。前缀和有两种，一种是hashmap的前缀和，一**种是数组的前缀和，HashMap的前缀和可以快速找到下标，适合==target，而数组的前缀和则是适合>target的，如果是**nums[i]都非负数**，用前缀和+滑动窗口即可，如果有非负数，**一定要用数组的前缀和+单调栈**。
## 模板
* 前缀和个数
```java
	HashMap<Integer,Integer> m;
	main(){
	int cur=0,ans=0；
	m.put(0,1);
	for(int i=0;i<nums.length;i++){
	cur+=nums[i];//记录前缀和
	ans+=m.getOrdefault(cur-target,0);//当temp-target,当他出现过之前的前缀和时候，那么这一段就是符合题意
	m.put(temp,m.getOrdefault(temp,0)+1);
}
}
```
* 前缀和长度 
```java
	HashMap<Integer,Integer> m;
	main(){
	int cur=0,length=Max；
	m.put(0,-1);
	for(int i=0;i<nums.length;i++){
	cur+=nums[i];//记录前缀和
	if(m.containsKey(cur-k)) lenth=Math.min(length,i-m.get(cur-k));
	else m.put(cur,i);}
	return length==Max?-1:length;
}
```
*  437.路径总和 III
## 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
```java
class Solution {
    HashMap<Integer,Integer> m=new HashMap<>();
    int ans=0,target;
    void dfs(TreeNode root,int temp){
        if(root==null) return ;
        temp+=root.val;
        ans+=m.getOrDefault(temp-target,0);
        m.put(temp,m.getOrDefault(temp,0)+1);
        dfs(root.left,temp);
        dfs(root.right,temp);
        m.put(temp,m.getOrDefault(temp,0)-1);
    }
    public int pathSum(TreeNode root, int targetSum) {
        target=targetSum;
        m.put(0,1);
        dfs(root,0);
        return ans;
    }
}
```
*  560.和为 K 的子数组
##### 题目
给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

##### 思路
一开始想用dp,但是太麻烦了，然后用了回溯，超时了，因为是连续的，所以可以用`前缀和`
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int pre=0,ans=0;
        HashMap<Integer,Integer> m=new HashMap<>();
        m.put(0,1);
        for(int i=0;i<nums.length;i++){
            pre+=nums[i];
            ans+=m.getOrDefault(pre-k,0);
            m.put(pre,m.getOrDefault(pre,0)+1);
        }
        return ans;
    }
}
```
* 862. 和至少为 K 的最短子数组

## 题目
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。
## 思路
**因为nums[i]有非负数**，因此是数组形式的前缀和＋单调栈
```java
class Solution {
    public int shortestSubarray(int[] nums, int k) {
        int length=Integer.MAX_VALUE;
        long[] A=new long[nums.length+1];
        for(int i=0;i<nums.length;i++){
            if(nums[i]>=k) return 1;
            A[i+1]=A[i]+nums[i];
        }
        Deque<Integer> q=new LinkedList<Integer>();
        for(int i=0;i<A.length;i++){
            while(!q.isEmpty()&&A[i]<=A[q.getLast()]){
                q.removeLast();
            }
            while(!q.isEmpty()&&A[i]-A[q.getFirst()]>=k){
                length=Math.min(length,i-q.getFirst());
                q.removeFirst();
            }
            q.add(i);
        }
        return length==Integer.MAX_VALUE?-1:length;
    }
}
```
