单调栈
题型1：关键词-下一个更大
题型2：求面积
求面积有一个需要注意的是，当比它小才开始弹出计算（首位都是0），并且在**取宽**的时候非常有细节
## 模板
```java
Stack<Integer> s=new Stack<>(); 
for(int i=0;i<nums.length;i++){
     while(!s.isEmpty()&&nums[s.peek()]>nums[i]){
         //处理，注这里会涉及i但是一般不会涉及nums[i],但是nums[s.peek()]>nums[i]会无形中加了约束
     }
    s.add(i);
 }
```
* 739.每日温度.md
## 题目

请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

## 思路

找数组后面比前面大的思路是单调栈

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> s=new Stack<>();
        int[] ans=new int[temperatures.length];
        for(int i=0;i<temperatures.length;i++){
            while(!s.isEmpty()&&temperatures[s.peek()]<temperatures[i]) ans[s.peek()]=i-s.pop();;
            s.push(i);
        }
        return ans;
    }
}
```

* 42.接雨水
## 题目
给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
## 思路
找到比它小的洼地，然后算体积
```java
class Solution {
    public int trap(int[] height) {
        int water=0;
        Stack<Integer> s=new Stack<>();
        for(int i=0;i<height.length;i++){
            while(!s.isEmpty()&&height[s.peek()]<height[i]){
                int low=s.pop();
                while(!s.isEmpty()&&height[low]==height[s.peek()]) s.pop();//去除相同高度的底部
                if(s.isEmpty()) break;
                int heigh=Math.min(height[s.peek()],height[i])-height[low];
                water+=(i-s.peek()-1)*heigh;//用peek,即便去重的时候low更新了用low不知道为什么会错
                }
            s.push(i);
        }
        return water;
    }
}
```
* 84.柱状图中最大的矩形
## 题目

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

## 思路

单调栈，思路非常的巧妙，比如说 2 1 5 6 4 3，2先入栈，遇到1小于栈顶2 ，则对栈内进行计算，

记录宽（i-s.peek（）），长就是栈顶长，这里有个非常巧妙的地方，就虽然栈5，6已经弹出了，但是因为1还在，所以我们知道1前面的肯定是比4还大；更加巧妙的是队首队尾设置两个0，针对特殊情况，如全部弹出后仍知道前面的数字比当前数字还大

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int[] temp=new int[heights.length+2];//前后各加一个0，强制弹出
        for(int i=1;i<heights.length+1;i++) temp[i]=heights[i-1];
        int ans=0;
        Stack<Integer> s=new Stack<>();
        for(int i=0;i<temp.length;i++){
            while(!s.isEmpty()&&temp[s.peek()]>temp[i]){
                int cur=s.pop();
                ans=Math.max(ans,(i-s.peek()-1)*temp[cur]);//这里基本根temp[i]没有关系，说明当前的长度不计入计算，这点很神奇
            }
            s.push(i);
        }
        return ans;
    }
}
```
* 85.最大矩形

## 题目
给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。
## 思路
84题的升级版，从上到小迭代即可
```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0||matrix[0].length==0) return 0;
        int y=matrix.length,x=matrix[0].length,max=0;
        int[] temp=new int[x+2];
        Stack<Integer> s=new Stack<>();
        for(int i=0;i<y;i++){
            for(int j=0;j<x+2;j++){
                if(j>0&&j<=x){
                    if(matrix[i][j-1]=='1') temp[j]+=1;
                    else temp[j]=0;
                    }
                while(!s.isEmpty()&&temp[s.peek()]>temp[j]){
                    int cur=s.pop();
                    max=Math.max(max,(j-s.peek()-1)*temp[cur]);
                }
                s.push(j);
            }
        }
        return max;
    }
}
```
* 402.移掉 K 位数字

## 题目
给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

## 思路.

单调栈
```java
class Solution {
    public String removeKdigits(String num, int k) {
        LinkedList<Integer> s=new LinkedList<>();
        int[] intnum= new int[num.length()+2];
        for(int i=1;i<=num.length();i++) intnum[i]=num.charAt(i-1)-'0';
        for(int i=0;i<intnum.length;i++){
            while(k>0&&s.size()!=0&&s.getLast()>intnum[i]) {
                s.removeLast();
                k--;
            }
            s.add(intnum[i]);
        }
        while(s.size()>0&&s.getFirst()==0) s.removeFirst();
        if(s.size()>0) s.removeLast();
        StringBuilder ans=new StringBuilder();
        for(int i=0;i<s.size();i++){
            ans.append(s.get(i));
        }
        return !ans.toString().equals("")?ans.toString():"0";
    }
}
```

* 503.下一个更大元素 II
## 题目
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
## 思路
关键词**下一个**，说明是单调栈，因为有循环，因此把长度放大到两倍
```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] ans=new int[nums.length];
        Stack<Integer> s=new Stack<>();  
        Arrays.fill(ans,-1);
        int n=ans.length;
        for(int i=0;i<nums.length*2;i++){
            while(!s.isEmpty()&&nums[s.peek()%n]<nums[i%n]){
                ans[s.pop()%n]=nums[i%n];
            }
            s.add(i);
        }     
        return ans;
    }
}
```


