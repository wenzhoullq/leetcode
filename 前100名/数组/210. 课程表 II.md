## 题目
现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。

例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。
## 思路
BFS和入度矩阵
```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> course=new LinkedList<>();
        int[] rudu=new int[numCourses],ans=new int[numCourses];
        int count=0,num=numCourses;
        for(int i=0;i<prerequisites.length;i++){
            rudu[prerequisites[i][0]]++;
        }
        Queue<Integer> q=new LinkedList<Integer>();
        for(int i=0;i<numCourses;i++){
            if(rudu[i]==0) {
                q.add(i);
                ans[count++]=i;
                num--;
            }
            course.add(new LinkedList<Integer>());
        }
        for(int i=0;i<prerequisites.length;i++){
            course.get(prerequisites[i][1]).add(prerequisites[i][0]);
        }
        while(!q.isEmpty()){
            int length=q.size();
            for(int i=0;i<length;i++){
                List<Integer> temp=course.get(q.poll());
                for(int j=0;j<temp.size();j++){
                    if(--rudu[temp.get(j)]==0) {
                        ans[count++]=temp.get(j);
                        q.add(temp.get(j));
                        num--;
                    }
                }
            }
        }
        return num==0?ans:new int[0];
    }
}
```
