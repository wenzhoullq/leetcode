## 题目

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

## 思路

用具体的数字来看 如 1 2 7 6 5 3 1，肯定是从尾部开始找，我们找到一个 2和7，然后从尾部开始找，找第一个大于2的数字（加入是找到比2小的，如1，那么结果肯定变小）；但是很明显，交换了之后

1 3 7 6 5 2 1并不是最小的数字，最小的是  1 3 1 2 5 6 7，因此我们需要对7 6 5 2 1进行升序排序

```
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length<2) return ;
        for(int i=nums.length-1;i>=1;i--){
            if(nums[i]>nums[i-1]){
                for(int j=nums.length-1;j>=i;j--){
                if(nums[i-1]<nums[j]){
                    int temp=nums[i-1];
                    nums[i-1]=nums[j];
                    nums[j]=temp;
                    Arrays.sort(nums,i,nums.length);
                    return ;
                }
              }
            }
        }
        Arrays.sort(nums);
    }
}
```

