## 模板
```java
    main(){
        if(空) return A
        if(空) return B
        if(满足) A.xx=mian(A.xx,B);
        else B.xx=main(A,B.xx);
    }
```

链表合并
==
##### 思路
升序链表合并的经典`递归模板`，对于两条链表效率比较高，但是对于多条链表的话，效率比较低，应该采用`分治法`

* 21.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
       if(l1==null) return l2;
       if(l2==null) return l1;
       if(l1.val<l2.val)
       {
           l1.next=mergeTwoLists(l1.next,l2);
           return l1;
       }
       else {
           l2.next=mergeTwoLists(l2.next,l1);
           return l2;
       }
    }
}
```
        这个是链表合并的经典模板
* 23.合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

#### 法一
经典升序链表合并模板
```java

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ListNode ans;
    ListNode merge(ListNode l1,ListNode l2){
        if(l1==null) return l2;
        if(l2==null) return l1;
        if(l1.val<l2.val){
            l1.next=merge(l1.next,l2);
            return l1;
        }
        else {
            l2.next=merge(l2.next,l1);
            return l2;
        }
    }
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0) return ans;
        if(lists.length==1) return lists[0];
        ans=lists[0];
       for(int i=1;i<lists.length;i++){
           ans=merge(ans,lists[i]);
       } 
       return ans;
    }
}
```
树的合并
=
* 617.合并二叉树
###### 题目
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
###### 思路
类似于链表的合并，采用`递归`的方法，树的合并模板差不多
```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null) return root2;
        else if(root2==null) return root1;
        root1.val+=root2.val;
        root1.left=mergeTrees(root1.left,root2.left);
        root1.right=mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```
