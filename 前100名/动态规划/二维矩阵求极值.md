## 模板
出现多少条路径或则最小值，即求某一个`极值`的时候，用`动态规划`
* 62.不同路径
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
        for(int y=0;y<m;y++){
            for(int x=0;x<n;x++){
                if(x==0||y==0){
                    dp[y][x]=1;
                    continue;
                }
                dp[y][x]=dp[y-1][x]+dp[y][x-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```
* 64.最小路径和
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid.length==0||grid[0].length==0) return 0;
        int m=grid.length,n=grid[0].length;
        int[][] dp=new int[m][n];
        for(int y=0;y<m;y++){
            for(int x=0;x<n;x++){
                if(x==0||y==0){
                    if(x==0&y==0) dp[0][0]=grid[0][0];
                    else if(x==0) dp[y][x]=dp[y-1][x]+grid[y][x];
                    else dp[y][x]=dp[y][x-1]+grid[y][x];
                }
                else dp[y][x]=Math.min(dp[y][x-1],dp[y-1][x])+grid[y][x];
            }
        }
        return dp[m-1][n-1];
    }
}
```
