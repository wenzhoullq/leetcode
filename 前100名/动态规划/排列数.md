*   70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

### 动态规划
最简单跳楼梯题目

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp=new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

*   55.跳跃游戏

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

### 动态规划
 跳格子很容易想到动态规划
 
 ```java
  class Solution {
    public boolean canJump(int[] nums) {
    boolean[] dp=new boolean[nums.length+1];
    dp[1]=true;
    for(int i=1;i<=nums.length;i++){
        for(int j=i-1;j>=1;j--){
            if(dp[j]==true&&j+nums[j-1]>=i) {
                dp[i]=true;
                break;
            }
        }
    }
    return dp[nums.length];
}
}
 ```
 
### 贪心算法
这里贪心算法的复杂度优于动态规划,最大跳远距离=max(当前点+跳跃距离,最大跳远距离)，最大跳远距离小于当前位置就不能到达

```java
class Solution {
    public boolean canJump(int[] nums) {
        int index=0;
        for(int i=0;i<nums.length;i++){
            if(index<i) return false;
            index=Math.max(index,i+nums[i]);
        }
        return true;
    }
}
```
* 322. 零钱兑换

## 题目
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。
## 思路
排列数
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount==0) return 0;
        int[] dp=new int[amount+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        Arrays.sort(coins);
        for(int i=1;i<=amount;i++){
            for(int j=0;j<coins.length;j++){
                if(coins[j]>i) break;
                if(dp[i-coins[j]]==Integer.MAX_VALUE) continue;
                dp[i]=Math.min(dp[i],dp[i-coins[j]]+1);
            }
        }
        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];
    }
}
```
