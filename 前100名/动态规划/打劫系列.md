*   198.打家劫舍 I
#####  题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

##### 思路
`数组求极值`用`动态规划`，跟股票那题类似

```java
class Solution {
    public int rob(int[] nums) {
        int[][] dp=new int[nums.length+1][2];//0是偷了，1是没偷
        for(int i=1;i<=nums.length;i++){
            dp[i][0]=dp[i-1][1]+nums[i-1];
            dp[i][1]=Math.max(dp[i-1][0],dp[i-1][1]);
        }
        return Math.max(dp[nums.length][0],dp[nums.length][1]);
    }
}
```
* 337.打家劫舍 III
## 题目

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

## 思路

动态规划，但是不一样的点是他是树的动态规划，结合了两者的特点，也是dfs访问到叶子节点慢慢返回回根节点，最后查询根节点

```java
class Solution {
    int[] dfs(TreeNode root){
        if(root==null) return new int[2]; 
        int[] left=dfs(root.left),right=dfs(root.right);
        int rob=left[0]+right[0]+root.val;
        int notrob=Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        return new int[]{notrob,rob};
    }
    public int rob(TreeNode root) {
        int[] ans=dfs(root);
        return Math.max(ans[0],ans[1]);
    }
}
```
* 213.打家劫舍 II.md
##### 题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，**这意味着第一个房屋和最后一个房屋是紧挨着的**。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

##### 思路

主要是它是围成一圈的，因此我们需要写两个dp，分别是抢劫了第一个房间和没有抢劫第一个房间，然后对边缘进行处理

```java
class Solution {
    public int rob(int[] nums) {
        int[][] robfirst=new int[nums.length][2];
        int[][] notrobfirst=new int[nums.length][2];
        for(int i=0;i<nums.length;i++){
            if(i==0){
                robfirst[0][1]=nums[i];
            }
            else if(i==nums.length-1){
                robfirst[i][0]=Math.max(robfirst[i-1][0],robfirst[i-1][1]);
                notrobfirst[i][0]=Math.max(notrobfirst[i-1][0],notrobfirst[i-1][1]);
                notrobfirst[i][1]=notrobfirst[i-1][0]+nums[i];
            }
            else {
                robfirst[i][0]=Math.max(robfirst[i-1][0],robfirst[i-1][1]);
                robfirst[i][1]=robfirst[i-1][0]+nums[i];
                notrobfirst[i][0]=Math.max(notrobfirst[i-1][0],notrobfirst[i-1][1]);
                notrobfirst[i][1]=notrobfirst[i-1][0]+nums[i];
            }
           
        } 
        return Math.max(Math.max(robfirst[nums.length-1][0],robfirst[nums.length-1][1]),Math.max(notrobfirst[nums.length-1][1],notrobfirst[nums.length-1][0]));
    }
}
```

