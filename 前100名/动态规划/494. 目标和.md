## 题目
给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
## 思路
这里是返回一个数字，所以想到的是`动态规划`，类似于416.分割等和子集，但是动态规划无论是复杂度还是做题难度都并不好，最简单的思路应该是回溯，但是复杂度较高
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum=0;
        for(int i=0;i<nums.length;i++) sum+=Math.abs(nums[i]);
        if(Math.abs(target)>sum) return 0;
        int[][] dp=new int[nums.length+1][sum*2+1];//使用sum*2+1可以将正负值合在一起，如果分开正负的话会出现正数组的0和负数组的0，重复计算
        dp[0][sum]=1;
        for(int i=1;i<=nums.length;i++){//在dp循环中，第一重循环是对前面的循环，第二重是对后面的循环，看起来像是说了废话，但是一下子想不到的时候考虑这个
            for(int j=0;j<sum*2+1;j++){
                int temp=Math.abs(nums[i-1]);
                if(j>=temp) dp[i][j]+=dp[i-1][j-temp];//在boolean dp中可能需要抄录上一个dp[i-1][j],但是这里是int[][] dp，只需要加即可
                if(j+temp<=sum*2) dp[i][j]+=dp[i-1][j+temp];
            }
        }
        return dp[nums.length][sum+target];
    }
}
```
