## 题目
给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
## 思路
这里是返回一个数字，所以想到的是`动态规划`，类似于416.分割等和子集，但是动态规划无论是复杂度还是做题难度都并不好，因此用回溯更好，这里采用动态规划
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int count=0;
        for(int i=0;i<nums.length;i++) count+=Math.abs(nums[i]);
        if(count<Math.abs(target)) return 0;
        int[][] dpP=new int[nums.length][count+1];
        int[][] dpN=new int[nums.length][count+1];
        for(int i=0;i<nums.length;i++){//第一重是对nums的循环
            if(i==0){
                dpP[i][nums[i]]=1;
                dpN[i][nums[i]]=1;
                if(nums[i]==0){//这里有个挖坑的地方，就是当初始化i=0的时候，如果是0的话，那么±数组的0都需要＋1，+-0都是0
                    dpP[i][nums[i]]+=1;
                    dpN[i][nums[i]]+=1;
                }
                continue;
            }
            for(int j=0;j<=count;j++){
                if(j>nums[i]) {
                    dpP[i][j]=+dpP[i-1][j-nums[i]];
                    dpN[i][j]=+dpN[i-1][j-nums[i]];
                    if(j+nums[i]<=count){
                        dpP[i][j]+=dpP[i-1][j+nums[i]];
                        dpN[i][j]+=dpN[i-1][j+nums[i]];
                    }
                }     
                else{
                    dpP[i][j]=+dpN[i-1][nums[i]-j];            
                    dpN[i][j]=+dpP[i-1][nums[i]-j]; 
                    if(j+nums[i]<=count){
                        dpP[i][j]+=dpP[i-1][j+nums[i]];
                        dpN[i][j]+=dpN[i-1][j+nums[i]];
                    }  
                }                         
            }
        }
        return dpP[nums.length-1][Math.abs(target)];
    }
}
```
