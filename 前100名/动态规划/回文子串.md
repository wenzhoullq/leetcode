##### 题目

* 5.最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

##### 思路

动态规划，dp[][] 二维数组，第一个[i]是起始下标，第二[j]是结束下标；
采用二重for循环，for(i=0;i<length;i++){
                    for(int j=0;j<=i;j++)} 
每一次比较的时候，i都是不变的，变化的是j（因为i++结束下标变化了，因此j要从头开始比较），比较s.charAt(i)==s.charAt(j),当i-j<=2时,即为回文，另一个注意的点是`dp[j+1][i-1]在上一层循环可能比较过了，动态规划的思想就是拿前面一次的来。
```java
    class Solution {
      public String longestPalindrome(String s) {
        int length=s.length(),l=0,start=0,end=0;
        boolean[][] dp=new boolean[length][length];
        for(int i=0;i<length;i++){
            for(int j=0;j<=i;j++){
                if(s.charAt(i)==s.charAt(j)&&(i-j<=2||dp[j+1][i-1])) {
                    dp[j][i]=true;
                    if(i-j+1>l){
                        l=i-j+1;
                        start=j;
                        end=i;
                    }
                }
                else dp[j][i]=false;
            }
        }
        return s.substring(start,end+1);    //注：substring(int i,int j) 中的i和j分别是起始点的下标和终点的下标，其中终点的下标需要+1
      }
    }
```
* 647.回文子串
##### 题目

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

##### 思路

求个数，回文子串，使用`动态规划`，二维数组，i是第几个字符，同时也是尾，j是开始

```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] dp=new boolean[s.length()+1][s.length()+1];
        int count=0;
        char[] c=s.toCharArray();
        for(int i=1;i<=s.length();i++){
            for(int j=1;j<=i;j++){
                if(c[j-1]==c[i-1]&&(i-j<=2||dp[i-1][j+1])){
                    dp[i][j]=true;
                    count++;
                }
            }
        }
        return count;
    }
}
```

