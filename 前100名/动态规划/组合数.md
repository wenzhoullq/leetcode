## 思路
题目形式为 选不连续的一些数得到目标值 ，其中目标值在0~sum之中
## 模板
* 二维版

```java
    boolean[][] dp=new boolean[被选数组集合.length+1][所有的数之和+1];
    for(int i=0;i<nuns.length;i++) dp[i][0]= true;
    for(int i=1;i<=被选数组集合.length;i++){
      for(int j=1;j<=所有的数之和+1;j++){
              dp[i][j]=dp[i-1][j];
              if(不满足) continue;
              dp[i][j]=dp[i][j-nums[i-1]];
              if(dp[i][j]满足) return
      }
    }
    return 不满足;
```
* 一维版

```java
    boolean[] dp=new boolean[所有的数之和+1];
    for(int i=0;i<nuns.length;i++) dp[i][0]= true;
    for(int i=1;i<=被选数组集合.length;i++){
      for(int j=1;j<=所有的数之和+1;j++){
              if(不满足) continue;
              dp[j]+=dp[j-nums[i-1]];
              if(dp[j]满足) return
      }
    }
```
1. 

|        | 0    | 1    | 2    | 3    | 4    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| num[0] |      |      |      |      |      |
| num[1] |      |      |      |      |      |
| num[2] |      |      |      |      |      |

每次进入下一行，先抄录上一行的结果，再进行计算
*  416.分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
## 思路
完全背包问题
* 二维DP
```java
class Solution {
    public boolean canPartition(int[] nums) {
        Arrays.sort(nums);
        int sum=0;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }
        if(sum%2!=0) return false;
        boolean[][] dp=new boolean[nums.length+1][sum/2+1];
        dp[0][0]=true;
        for(int i=1;i<=nums.length;i++){
            for(int j=1;j<=sum/2;j++){
                dp[i][j]=dp[i-1][j];
                if(j<nums[i-1]||dp[i][j]) continue;
                dp[i][j]=dp[i-1][j-nums[i-1]];
                if(dp[i][sum/2]) return true;
            }
        }
        return false;
    }
}
```
* 一维DP

```java
class Solution {
    public boolean canPartition(int[] nums) {
        Arrays.sort(nums);
        int sum=0;
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
        }
        if(sum%2!=0) return false;
        boolean[] dp=new boolean[sum/2+1];
        dp[0]=true;
        for(int i=0;i<nums.length;i++){
            for(int j=sum/2;j>=1;j--){//需要逆序，不然会覆盖
                if(j<nums[i]||dp[j]) continue;
                dp[j]=dp[j]||dp[j-nums[i]];
                if(dp[sum/2]) return true;
            }
        }
        return false;
    }
}
```
*  518.零钱兑换 II

## 题目
给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 
## 思路
组合数问题
* 二维版
```java
class Solution {
    public int change(int amount, int[] coins) {
        int[][] dp=new int[coins.length+1][amount+1];
        for(int i=0;i<=coins.length;i++) dp[i][0]=1;
        Arrays.sort(coins);
        for(int i=1;i<=coins.length;i++){
            int coin=coins[i-1];
            for(int j=1;j<=amount;j++){
                if(coin<=j) dp[i][j]=dp[i][j-coin]+dp[i-1][j];
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[coins.length][amount];
    }
}
```
* 一维版

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp=new int[amount+1];
        Arrays.sort(coins);
        dp[0]=1;
        for(int i=0;i<coins.length;i++){
            for(int j=1;j<=amount;j++){
                if(j<coins[i]) continue;
                dp[j]+=dp[j-coins[i]];
            }
        }
    return dp[amount];
    }
}
```
* 面试题 08.11. 硬币

## 题目
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
## 思路
本质上还是组合数，不是排列数，但是硬币不限，可以不用二维dp
```java
class Solution {
    public int waysToChange(int n) {
        int[] coins={1,5,10,25};
        int[] dp=new int[n+1];
        dp[0]=1;
        for(int i=0;i<4;i++){
            for(int j=1;j<=n;j++){
                if(coins[i]>j) continue;
                dp[j]=(dp[j]+dp[j-coins[i]])%(1000000007);
            }
        }
        return dp[n];
    }
}
```
