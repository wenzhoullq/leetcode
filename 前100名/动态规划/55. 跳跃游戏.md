## 题目 

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

* 动态规划
 跳格子很容易想到动态规划
 
 ```java
  class Solution {
    public boolean canJump(int[] nums) {
    boolean[] dp=new boolean[nums.length+1];
    dp[1]=true;
    for(int i=1;i<=nums.length;i++){
        for(int j=i-1;j>=1;j--){
            if(dp[j]==true&&j+nums[j-1]>=i) {
                dp[i]=true;
                break;
            }
        }
    }
    return dp[nums.length];
}
}
 ```
 
 * 贪心算法
这里贪心算法的复杂度优于动态规划,最大跳远距离=max(当前点+跳跃距离,最大跳远距离)，最大跳远距离小于当前位置就不能到达

```java
class Solution {
    public boolean canJump(int[] nums) {
        int index=0;
        for(int i=0;i<nums.length;i++){
            if(index<i) return false;
            index=Math.max(index,i+nums[i]);
        }
        return true;
    }
}
```
