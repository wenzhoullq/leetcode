## 模板
模板形式，根据题意增加状态，或则交易次数无限退化成二维
```java
    int[][][] dp=new int[length+1][2][k+1];
    for(int i=0;i<=k;i++){ //对第0次买卖初始化
           dp[0][0][i]=-prices[0];
           dp[0][1][i]=-prices[0]; 
        }
    for(int i=1;i<=length;i++){
        for(int j=1;j<=k;j++){
             dp[i][0][j]=Math.max(dp[i-1][0][j],dp[i-1][1][j-1]-prices[i-1]);
             dp[i][1][j]=Math.max(dp[i-1][1][j],dp[i-1][0][j]+prices[i-1]);//注意卖出时候是第j次
        }
    }
    return dp[prices.length][1][k];
```

*  121.买卖股票的最佳时机

## 题目

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

## 思路
这里采用了`动态规划`的思路，但是动态规划在这题不是最优的解，反而效率一般般，但是股票的题用动态规划是最模板的题,每一天的状态分为持股和空仓，持股是今天买了或则之前买了，空仓是之前
就没买或则今天卖了，按这个思路来即可

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp=new int[prices.length+1][2];//0有股票，1没股票
        int max=0;
        dp[0][0]=-prices[0];
        for(int i=1;i<=prices.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],-prices[i-1]);
            dp[i][1]=Math.max(dp[i-1][0]+prices[i-1],dp[i-1][1]);
            max=Math.max(max,dp[i][1]);
        }
        if(max>0) return max;
        return 0;
    }
}
```

*  309.最佳买卖股票时机含冷冻期

## 题目
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

## 思路 
动态规划，思路同上，但是增加一种状态

```java
class Solution {
    public int maxProfit(int[] prices) {
        int length=prices.length;
        int[][] dp=new int[length+1][3];//0代表持股 1代表冷冻期 2代表空仓 
        dp[0][0]=-prices[0];
        for(int i=1;i<=length;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i-1]);
            dp[i][1]=dp[i-1][0]+prices[i-1];
            dp[i][2]=Math.max(dp[i-1][1],dp[i-1][2]);
        }
        return Math.max(dp[length][1],dp[length][2]);
    }
}
```
* 123.买卖股票的最佳时机 III.md
## 题目

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 思路

* 法一
写两个dp分别代表第1，2次买卖

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp1=new int[prices.length+1][2];//0是买，1是卖
        int[][] dp2=new int[prices.length+1][2];
        dp1[0][0]=-prices[0];
        dp2[0][0]=-prices[0];
        for(int i=1;i<=prices.length;i++){
            dp1[i][0]=Math.max(dp1[i-1][0],-prices[i-1]);
            dp1[i][1]=Math.max(dp1[i-1][1],dp1[i-1][0]+prices[i-1]);
            dp2[i][0]=Math.max(dp1[i-1][1]-prices[i-1],dp2[i-1][0]);
            dp2[i][1]=Math.max(dp2[i-1][1],dp2[i-1][0]+prices[i-1]);
        }
        return dp2[prices.length][1];
    }
}
```
* 法二

模板化
```
class Solution {
    public int maxProfit(int[] prices) {
        int[][][] dp=new int[prices.length+1][2][3];//0是持有，1是空仓
        for(int i=0;i<=2;i++){
           dp[0][0][i]=-prices[0];
           dp[0][1][i]=-prices[0]; 
        }
        for(int i=1;i<=prices.length;i++){
            for(int j=1;j<=2;j++){
                dp[i][0][j]=Math.max(dp[i-1][0][j],dp[i-1][1][j-1]-prices[i-1]);
                dp[i][1][j]=Math.max(dp[i-1][1][j],dp[i-1][0][j]+prices[i-1]);
            }
        }
        return dp[prices.length][1][2];
    }
}
```
* 188.买卖股票的最佳时机 IV

## 题目
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
## 思路
买卖股票的最佳时机 III的升级版，需要注意的是初始化第0天各个交易次数都需要初始化以及第j笔的空仓是第**j**笔而不是第（j-1）笔的满仓卖出
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int length=prices.length;
        if(length==0||k==0) return 0;
        int[][][] dp=new int[length+1][2][k+1];//0是has 1是empty
        for(int i=0;i<=k;i++){
            dp[0][0][i]=-prices[0];
            dp[0][1][i]=-prices[0];
        }
        for(int i=1;i<=length;i++){
            for(int j=1;j<=k;j++){
                dp[i][0][j]=Math.max(dp[i-1][0][j],dp[i-1][1][j-1]-prices[i-1]);
                dp[i][1][j]=Math.max(dp[i-1][1][j],dp[i-1][0][j]+prices[i-1]);//第j笔的空仓是第**j**笔而不是第（j-1）笔的满仓卖出
            }
        }
        return dp[prices.length][1][k];
    }
}
```
* 714.买卖股票的最佳时机含手续费
## 题目
给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
## 思路
dp,主要的在卖出去时收手续费，然后第0次卖出时不收
```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int k=prices.length/2,length=prices.length,ans=0;
        int[][] dp=new int[length+1][2];//0持有，1空仓
        dp[0][0]=-prices[0];
        dp[0][1]=-prices[0];
        for(int i=1;i<=length;i++){
            dp[i][0]=Math.max(dp[i-1][1]-prices[i-1],dp[i-1][0]);
            if(i!=1) dp[i][1]=Math.max(dp[i-1][0]+prices[i-1]-fee,dp[i-1][1]);
            else  dp[i][1]=0;
            ans=Math.max(ans,dp[i][1]);
        }
        return ans;
    }
}
```
