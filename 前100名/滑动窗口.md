## 模板
本质是双指针甚至三指针，固定一个left;   right指针不断移动，寻找到**满足的**不断对left进行滑动至**极限**,**数字类滑动窗口**有一个很大的前提，就是**保证所有的数字都是非负的**
```java
int left=0,right=nums.length-1;
  for(int i=0;i<nums.length;i++){
    if(满足条件){
      while(不断移动左指针至不满足)
    }
  }
```
* 异位词 

出现异位词或则子串并且子串的顺序可以打乱,char[]之间的比较
```java
    char[] str=new char[26],s=new char[26];//目标数组
   int count=0;
   for(int i=0;i<s.length();i++){
      str[s.charAt(i)-'a']++;
      }
    for(int i=0;i<t.length();t++){
        s[i]不断加减,移动左右指针，如果满足,(Arrays.equals(str,s))，则return true;
    }
    return false;
```
* 3 无重复字符的最长子串
## 题目
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```java
      class Solution {
      public int lengthOfLongestSubstring(String s) {
        HashMap<Integer,Integer> m=new HashMap<>();
        int start=0,ans=0;
        for(int i=0;i<s.length();i++){
            int temp=s.charAt(i);
            if(m.containsKey(temp)) start=Math.max(start,m.get(temp)+1);
            m.put(temp,i);
            ans=Math.max(ans,i-start+1);
        }
        return ans;
       }
       }
```
* 239.滑动窗口最大值
## 题目
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。
## 思路
滑动窗口
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> q=new LinkedList<Integer>();
        int[] ans=new int[nums.length-k+1];
        for(int i=0;i<k;i++){
            while(!q.isEmpty()&&nums[q.getLast()]<=nums[i]) q.removeLast();
            q.offer(i);
        }
        for(int i=k;i<nums.length;i++){
            ans[i-k]=nums[q.getFirst()];
            while(!q.isEmpty()&&nums[q.getLast()]<=nums[i]) q.removeLast();
            while(!q.isEmpty()&&i-k+1>q.getFirst()) q.removeFirst();
            q.offer(i);
        }
        ans[nums.length-k]=nums[q.getFirst()];
        return ans;
    }
}
```
* 76.最小覆盖子串
## 题目
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
## 思路
用一个count[]来判定是否满足条件
```java
class Solution {
    public String minWindow(String s, String t) {
        int length1=s.length(),length2=t.length(),all=length2,length=Integer.MAX_VALUE,ansstart=0,tempstart=0;
        if(length1==0||length2==0||length2>length1) return "";
        int[] count=new int[256];
        for(int i=0;i<length2;i++) count[t.charAt(i)]++;
        for(int i=0;i<length1;i++){
            int temp=s.charAt(i);
            if(count[temp]-->0){
                all--;
                if(all==0){
                    while(all==0){
                        temp=s.charAt(tempstart++);
                        count[temp]++;
                        if(count[temp]>0){
                            all++;
                            break;
                        }  
                    }
                    if(i-tempstart+2<length){
                        length=i-tempstart+2;
                        ansstart=tempstart-1;
                    }
                }
            }
        }
        if(length==Integer.MAX_VALUE) return "";
        return s.substring(ansstart,ansstart+length);
    }
}
```
* 209.长度最小的子数组.md
## 题目
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
## 思路
经典滑动窗口思想
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int ans=Integer.MAX_VALUE,temp=0,left=0;
        for(int i=0;i<nums.length;i++){
            temp+=nums[i];
            if(temp>=target){
                while(temp>=target){
                temp-=nums[left];
                left++;
                }
                ans=Math.min(ans,i-left+2);
            }
        }
        return ans==Integer.MAX_VALUE?0:ans;
    }
}
```
*  567.字符串的排列

## 题目
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。
## 思路
异位词
```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] str1=new int[26],str2=new int[26],str3=new int[26];
        int count=0;
        for(int i=0;i<s1.length();i++){
            str1[s1.charAt(i)-'a']++;
            str2[s1.charAt(i)-'a']++;
            count++;
        }
        int left=0,right=0;
        while(right<s2.length()){
            int index=s2.charAt(right)-'a';
            if(str2[index]>0) count--;
            str2[index]--;
            str3[index]++;
            if(count==0){
                while(count==0){
                    int index2=s2.charAt(left)-'a';
                    if(str2[index2]+1>0){
                        if(Arrays.equals(str1,str3)) return true;
                        count++;
                    } 
                    str3[index2]--;
                    str2[index2]++;
                    left++;
                }
            }
            right++;
        }
        return false;
    }
}
```
* 76.最小覆盖子串
## 题目

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

## 思路

这个是滑动窗口，滑动窗口用int[]记录，当count=0时候就是正好全部匹配，然后这时候移动窗口，移动至不满足题意（count+1）,然后移动start (start和l是不同的东西，这个很重要，就像length一样，比如说前面abcaacb,需要匹配的是ab,那么如果是start一直在移动，后面会移动到acb，但是acb不是最短的)

```java
class Solution {
    public String minWindow(String s, String t) {
        if(s.length()==0||t.length()==0) return "";
        int[] temp=new int[256];
        int count=t.length(),start=0,length=Integer.MAX_VALUE,l=0;
        for(int i=0;i<t.length();i++) temp[t.charAt(i)]++;
        for(int i=0;i<s.length();i++){
            if(temp[s.charAt(i)]-->0) count--;
            if(count==0) {
                while(count==0){
                    temp[s.charAt(l)]++;
                    if(temp[s.charAt(l)]>0) count++;
                    l++;
                }
                if(length>i-l+2) {//start和l不是同一个东西，很重要
                    length=i-l+2;
                    start=l-1;
                }
            }
        }
        if(length==Integer.MAX_VALUE) return "";
        return s.substring(start,start+length);
    }
}
```

